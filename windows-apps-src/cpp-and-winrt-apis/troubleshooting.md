---
description: La tabla de síntomas y remedios de solución de problemas de este tema puede resultarte útil si vas a cortar nuevo código o a migrar una aplicación existente.
title: Solución de problemas de C++/WinRT
ms.date: 04/23/2019
ms.topic: article
keywords: windows 10, uwp, standard, c++, cpp, winrt, projection, troubleshooting, HRESULT, error
ms.localizationpriority: medium
ms.openlocfilehash: add3875e15ad747422b2e53e5d8f8438b61b3b20
ms.sourcegitcommit: d37a543cfd7b449116320ccfee46a95ece4c1887
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 07/16/2019
ms.locfileid: "68270099"
---
# <a name="troubleshooting-cwinrt-issues"></a>Solución de problemas de C++/WinRT

> [!NOTE]
> Para más información sobre cómo instalar y usar la [Extensión de Visual Studio (VSIX) de C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) (que proporciona compatibilidad de plantilla de proyecto), consulta [Compatibilidad de Visual Studio para C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).

Este tema se muestra por adelantado para que lo tengas en cuenta, aunque no lo necesites todavía. La siguiente tabla de síntomas y soluciones de problemas puede resultarte útil si vas a cortar nuevo código o portar una aplicación existente. Si estás portando, y deseas seguir avanzando y llegar a la etapa de creación y ejecución de tu proyecto, puedes progresar temporalmente comentando o anulando cualquier código no esencial que esté causando problemas, y volver después para restaurar lo que has quitado.

Para ver una lista de las preguntas más frecuentes, consulta [Preguntas más frecuentes](faq.md).

## <a name="tracking-down-xaml-issues"></a>Seguimiento de problemas XAML
Las excepciones de análisis XAML pueden ser difíciles de diagnosticar, especialmente si no hay ningún mensaje de error significativo dentro de la excepción. Asegúrate de que el depurador está configurado para capturar las primeras excepciones (para probar y capturar la excepción de análisis desde el principio). Podrás inspeccionar la variable de excepción en el depurador para determinar si el mensaje o HRESULT tiene información útil. Asimismo, consulta la ventana de salida de Visual Studio para comprobar si presenta mensajes de error emitidos por el analizador XAML.

Si tu aplicación finaliza y todo lo que sabes es que se ha producido una excepción no controlada durante el análisis de marcado XAML, podría ser el resultado de una referencia (por clave) a un recurso que falta. O bien, podría tratarse de una excepción dentro de UserControl, un control personalizado o un panel de diseño personalizado. Un último recurso es una división binaria. Quita aproximadamente la mitad del marcado de una página XAML y vuelve a ejecutar la aplicación. De este modo, sabrás si el error está en la mitad que quitaste (que ahora debes restaurar en cualquier caso) o en la mitad que no quitaste. Repite el proceso dividiendo la mitad que contiene el error y así sucesivamente, hasta que reduzcas a cero el problema.

## <a name="symptoms-and-remedies"></a>Síntomas y soluciones
| Síntoma | Solución |
|---------|--------|
| Se produce una excepción en tiempo de ejecución con un valor HRESULT de REGDB_E_CLASSNOTREGISTERED. | Consulta [¿Por qué se muestra la excepción "clase no registrada"?](faq.md#why-am-i-getting-a-class-not-registered-exception) |
| El compilador de C++ produce el error " *'implements_type': no es un miembro de ninguna clase base directa o indirecta de '&lt;tipo proyectado&gt;'* ". | Esto puede suceder cuando se llama a **make** con el nombre del espacio de nombres no completo de tu tipo de implementación (**MyRuntimeClass**, por ejemplo) y no has incluido el encabezado de dicho tipo. El compilador interpreta **MyRuntimeClass** como el tipo proyectado. La solución consiste en incluir el encabezado para el tipo de implementación (`MyRuntimeClass.h`, por ejemplo). |
| El compilador de C++ produce el error "*se está intentando hacer referencia a una función eliminada*". | Esto puede suceder cuando se llama a **make** y el tipo de implementación que pasas como parámetro de plantilla tiene un constructor `= delete` predeterminado. Edita el archivo de encabezado del tipo de implementación y cambia `= delete` a `= default`. También puedes agregar un constructor al archivo IDL para la clase en tiempo de ejecución. |
| Has implementado [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), pero tus enlaces de XAML no se actualizan (y la interfaz de usuario no se suscribe a [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Recuerda que tienes que establecer `Mode=OneWay` (o TwoWay) en tu expresión de enlace en marcado XAML. Consulta [Controles XAML; enlazar a una propiedad C++/WinRT](binding-property.md). |
| Vas a enlazar un control de elementos XAML a una colección observable y se produce una excepción en tiempo de ejecución con el mensaje "El parámetro no es correcto". | En tu IDL e implementación, declara cualquier colección observable como el tipo **Windows.Foundation.Collections.IVector<IInspectable>** . Pero devuelve un objeto que implementa **Windows.Foundation.Collections.IObservableVector<T>** , donde T es tu tipo de elemento. Consulta [Controles de elementos XAML; enlazar a una colección C++/WinRT](binding-collection.md).  |
| El compilador de C++ produce un error del formulario " *'MyImplementationType_base&lt;MyImplementationType&gt;': no hay disponible un constructor predeterminado adecuado*".|Esto puede suceder si has derivado de un tipo que tiene un constructor no trivial. Tu constructor del tipo derivado debe pasar los parámetros que el constructor del tipo base necesita. Para obtener un ejemplo trabajado, consulta [Derivar de un tipo que tiene un constructor no trivial](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor).|
| El compilador de C++ produce el error"*No se puede convertir de 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' a 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* ".|Esto puede suceder cuando se pasa std::vector de std::wstring a una API de Windows Runtime que espera una colección. Para más información, consulta [Tipos de datos C++ estándar y C++/WinRT](std-cpp-data-types.md).|
| El compilador de C++ produce el error"*No puede convertir de 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' a 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* ".|Esto puede suceder cuando se pasa std::vector de winrt::hstring a una API asincrónica de Windows Runtime que espera una colección y no has copiado ni movido el vector al destinatario asincrónico. Para más información, consulta [Tipos de datos C++ estándar y C++/WinRT](std-cpp-data-types.md).|
| Al abrir un proyecto, Visual Studio genera el error "*La aplicación del proyecto no está instalada*".|Si no lo has hecho todavía, debes instalar **herramientas universales de Windows para el desarrollo de C++** desde el cuadro de diálogo **Nuevo proyecto** de Visual Studio. Si esto no resuelve el problema, el proyecto puede depender de la Extensión de Visual Studio (VSIX) para C++/WinRT (consulta [Compatibilidad de Visual Studio para C++/WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package)).|
| Las pruebas del Kit de certificación de aplicaciones de Windows generan un error de que una de las clases en tiempo de ejecución "*no se deriva de una clase base de Windows. Todas las clases que admiten composición deben derivar en última instancia de un tipo en el espacio de nombres de Windows*".|Cualquier clase en tiempo de ejecución (que declares en la aplicación) que se deriva de una clase base se conoce como una clase *que admite composición*. La clase base fundamental de una clase que admite composición debe ser un tipo que se origina en un espacio de nombres de Windows.*; por ejemplo, [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Consulta [Controles XAML; enlazar a una propiedad C++/WinRT](binding-property.md) para más información.|
| El compilador de C++ genera un error "*debe ser de tipo WinRT*" para una especialización del delegado EventHandler o TypedEventHandler.|Considera la posibilidad de utilizar **winrt::delegate&lt;... T&gt;** en su lugar. Consulta [Crear eventos en C++/WinRT](author-events.md).|
| El compilador de C++ genera un error "*debe ser de tipo WinRT*" para una especialización de la operación asincrónica de Windows Runtime.|Considera la posibilidad de devolver una [**tarea**](https://docs.microsoft.com/cpp/parallel/concrt/reference/task-class) de la biblioteca de patrones de procesamiento paralelo (PPL) en su lugar. Consulta [Operaciones simultáneas y asincrónicas](concurrency.md).|
| El compilador de C++ genera el "*error C2220: advertencia tratada como error - ningún archivo 'objeto' generado*".|Corrige la advertencia o establece **C/C++**  > **General** > **Tratar advertencias como errores** en **No (/WX-)** .|
| La aplicación se bloquea porque se llama a un controlador de eventos en el objeto C++/WinRT un vez destruido el objeto.|Consulta [Acceso de forma segura al puntero *this* con un delegado de control de eventos](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).|
| El compilador de C++ genera el "*error C2338: This is only for weak ref support (Esto es solo para compatibilidad con referencia débil)* ".|Estás solicitando una referencia débil para un tipo que ha pasado la estructura de marcador **winrt::no_weak_ref** como argumento de plantilla a su clase base. Consulta [Rechazar el soporte de referencia débil](weak-references.md#opting-out-of-weak-reference-support).|
| El enlazador de C++ genera el "*error LNK2019: símbolo externo sin resolver*"|Consulta [¿Por qué el enlazador me da un "error LNK2019: símbolo externo sin resolver"?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error)|
| La cadena de herramientas de LLVM y Clang produce errores cuando se usa con C++/WinRT.|No admitimos la cadena de herramientas LLVM y Clang para C++/WinRT, pero si deseas emular cómo la utilizamos internamente, puedes intentar hacer un experimento, como el descrito en [¿Puedo usar LLVM/Clang para compilar con C++/WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).|
| El compilador de C++ genera "*no hay disponible un constructor predeterminado adecuado*" para un tipo proyectado. | Si estás intentando retrasar la inicialización de un objeto de clase en tiempo de ejecución, o consumir e implementar una clase en tiempo de ejecución en el mismo proyecto, debes llamar al constructor **std::nullptr_t**. Para más información, consulta [Consumir API con C++/WinRT](consume-apis.md). |
| El compilador de C++ genera el "*error C3861: 'from_abi': no se encontró el identificador*" y otros errores que se originan en *base.h*. Puedes ver este error si usas Visual Studio 2017 (versión 15.8.0 o superior) y te diriges al SDK de Windows versión 10.0.17134.0 (Windows 10, versión 1803). | Dirígete a una versión posterior (más compatible) del SDK de Windows o establece la propiedad del proyecto **C/C++**  > **Lenguaje** > **Modo de conformidad: No** (además, si **/permissive-** aparece en la propiedad del proyecto **C/C++**  > **Lenguaje** > **Línea de comandos** en **Opciones adicionales**, elimínalo). |
| El compilador de C++ genera el "*error C2039: 'IUnknown': no es un miembro de '\`global namespace*". | Consulta [Procedimientos para redirigir el proyecto de C++/WinRT a una versión posterior del SDK de Windows](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| El enlazador de C++ genera un "*error LNK2019: símbolo externo sin resolver_WINRT_CanUnloadNow@0 al que se hace referencia en la función _VSDesignerCanUnloadNow@0* ". | Consulta [Procedimientos para redirigir el proyecto de C++/WinRT a una versión posterior del SDK de Windows](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| El proceso de compilación genera el mensaje de error *The C++/WinRT VSIX no longer provides project build support.  Please add a project reference to the Microsoft.Windows.CppWinRT Nuget package* (VSIX de C++WinRT ya no proporciona compatibilidad con la compilación del proyecto. Agregue una referencia de proyecto al paquete NuGet Microsoft.Windows.CppWinRT). | Instala el paquete NuGet **Microsoft.Windows.CppWinRT** en el proyecto. Para más información, consulta [Versiones anteriores de la extensión VSIX](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension). |
| El enlazador de C++ genera el *error LNK2019: símbolo externo sin resolver*, con una mención de *winrt::impl::consume_Windows_Foundation_Collections_IVector*. | A partir de [C++/WinRT 2.0](news.md#news-and-changes-in-cwinrt-20), si usas `for` basado en intervalo en una colección de Windows Runtime, deberás aplicar ahora `#include <winrt/Windows.Foundation.Collections.h>`. |
| El compilador de C++ genera el error "*error C4002: demasiados argumentos para la invocación de la macro como función GetCurrentTime*". | Consulta [¿Cómo se pueden resolver las ambigüedades con GetCurrentTime o TRY?](faq.md#how-do-i-resolve-ambiguities-with-getcurrenttime-andor-try) |
| El compilador de C++ genera el error "*error C2334: tokens inesperados antes de '{'; se omite el cuerpo de función aparente*". | Consulta [¿Cómo se pueden resolver las ambigüedades con GetCurrentTime o TRY?](faq.md#how-do-i-resolve-ambiguities-with-getcurrenttime-andor-try) |
| El compilador de C++ genera el error "*winrt::impl::produce&lt;D,I&gt; no se puede crear una instancia de la clase abstracta, porque falta GetBindingConnector*". | Tienes que `#include <winrt/Windows.UI.Xaml.Markup.h>`. |
| El compilador de C++ genera el error "*error C2039: 'promise_type': no es un miembro de 'std::experimental::coroutine_traits<void>'* ". | Tu corrutina debe devolver un objeto de operación asincrónica o **winrt::fire_and_forget**. Consulta [Operaciones simultáneas y asincrónicas](concurrency.md). |
| El proyecto genera "*acceso ambiguo de 'PopulatePropertyInfoOverride'* ". | Este error puede producirse cuando se declaran una clase base en el archivo IDL y una clase base diferente en el marcado XAML. |
| Cargar una solución de C++/WinRT por primera vez genera el error "*Error de compilación en tiempo de diseño para la configuración del proyecto 'MyProject.vcxproj' 'Debug\|x86'. Es posible que IntelliSense no esté disponible.* ". | Después de compilar por primera vez, se resolverá este problema de IntelliSense. |
| Si intentas especificar [**winrt::auto_revoke**](/uwp/cpp-ref-for-winrt/auto-revoke-t) al registrar un delegado, se genera una excepción [**winrt::hresult_no_interface**](/uwp/cpp-ref-for-winrt/error-handling/hresult-no-interface). | Consulta [If your auto-revoke delegate fails to register](handle-events.md#if-your-auto-revoke-delegate-fails-to-register) (Si el delegado de revocación automática no se registra). |

> [!NOTE]
> Si en este tema no hemos respondido a tu pregunta, podrás encontrar ayuda en la [comunidad de desarrolladores de C++ de Visual Studio](https://developercommunity.visualstudio.com/spaces/62/index.html) o mediante la [etiqueta `c++-winrt` en Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
