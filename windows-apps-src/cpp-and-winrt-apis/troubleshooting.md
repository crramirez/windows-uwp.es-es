---
author: stevewhims
description: La tabla de solución de problemas de síntomas y soluciones de este tema puede resultarte útil si vas a cortar nuevo código o portar una aplicación existente.
title: Solucionar problemas de C++/WinRT
ms.author: stwhi
ms.date: 04/10/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp, estándar, c++, cpp, winrt, proyección, solución de problemas, HRESULT, error
ms.localizationpriority: medium
ms.openlocfilehash: 21f5fc4773979b2d7940b85871264e27d56d29c4
ms.sourcegitcommit: ab92c3e0dd294a36e7f65cf82522ec621699db87
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 05/03/2018
ms.locfileid: "1832269"
---
# <a name="troubleshooting-cwinrtwindowsuwpcpp-and-winrt-apisintro-to-using-cpp-with-winrt-issues"></a>Solucionar problemas de [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt)
> [!NOTE]
> **Parte de la información hace referencia a la versión preliminar del producto, el cual puede sufrir importantes modificaciones antes de que se publique la versión comercial. Microsoft no ofrece ninguna garantía, expresa o implícita, con respecto a la información que se ofrece aquí.**

> [!NOTE]
> Para obtener información sobre la actual disponibilidad de la extensión de Visual Studio (VSIX) de C++/WinRT (la cual ofrece soporte para plantillas de proyectos, así como propiedades y destinos de MSBBuild de C++/WinRT), consulta el [Soporte de Visual Studio para C++/WinRT, y VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).

Este tema es inicial para que puedas verlo ahora mismo; aunque no lo necesites todavía. La siguiente tabla de solución de problemas de síntomas y soluciones puede resultarte útil si vas a cortar nuevo código o portar una aplicación existente. Si vas a portar y estás deseando seguir avanzando y llegar a la etapa en la que tu proyecto se crea y se ejecuta, puedes progresar temporalmente comentando o anulando cualquier código no esencial que esté causando problemas, y más tarde volver para restaurar lo que has quitado.

## <a name="tracking-down-xaml-issues"></a>Seguimiento de problemas XAML
Las excepciones de análisis XAML pueden ser difíciles de diagnosticar&mdash;especialmente si no hay ningún mensaje de error significativo dentro de la excepción. Asegúrate de que el depurador está configurado para capturar las primeras excepciones (para probar y capturar la excepción de análisis desde el principio). Podrás inspeccionar la variable de excepción en el depurador para determinar si el mensaje o HRESULT tiene información útil. Asimismo, consulta la ventana de salida de Visual Studio para comprobar si presenta mensajes de error emitidos por el analizador XAML.

Si tu aplicación finaliza y todo lo que sabes es que se ha producido una excepción no controlada durante el análisis de marcado XAML, podría deberse al resultado de una referencia (por clave) a un recurso faltante. O bien, podría tratarse de una excepción dentro de un UserControl, un control personalizado o un panel de diseño personalizado. Un último recurso es una división binaria. Quita aproximadamente la mitad del marcado de una página XAML y vuelve a ejecutar la aplicación. De este modo, sabrás si el error está en a mitad que quitaste (que ahora debes restaurar) o en la mitad que no quitaste. Repite el proceso dividiendo la mitad que contiene el error y así sucesivamente, hasta que reduzcas a cero el problema.

## <a name="symptoms-and-remedies"></a>Síntomas y soluciones
| Síntoma | Solución |
|---------|--------|
| Se produce una excepción en tiempo de ejecución con un valor HRESULT de REGDB_E_CLASSNOTREGISTERED. | Una causa de este error es que no pueda cargarse tu componente de Windows Runtime. Asegúrate de que el archivo de metadatos (`.winmd`) de Windows Runtime del componente tenga el mismo nombre que el binario del componente (el `.dll`), que también es el nombre del proyecto y el nombre del espacio de nombres raíz. Asegúrate también de que el proceso de compilación haya copiado correctamente los metadatos de Windows Runtime y el binario en la carpeta `Appx` de consumo. Y comprueba que el `AppxManifest.xml` de la aplicación de consumo (también en la carpeta `Appx`) contenga un elemento **&lt;InProcessServer&gt;** que declare correctamente la clase activable y el nombre binario. Este error también puede ocurrir si cometes el error de crear instancias de una clase en tiempo de ejecución implementada localmente mediante el constructor predeterminado del tipo proyectado. Consulta [Controles XAML; enlazar a una propiedad C++/WinRT](binding-property.md) para obtener más información sobre cómo utilizar correctamente el tipo proyectado en este caso. |
| El compilador de C++ produce el error "*'implements_type': no es un miembro de ninguna clase base directa o indirecta de '&lt;tipo proyectado&gt;'*". | Esto puede suceder cuando se llama a **make** con el nombre del espacio de nombres no calificado de tu tipo de implementación (**MyRuntimeClass**, por ejemplo), y no has incluido el encabezado de dicho tipo. El compilador interpreta **MyRuntimeClass** como el tipo proyectado. La solución consiste en incluir el encabezado para el tipo de implementación (`MyRuntimeClass.h`, por ejemplo). |
| El compilador de C++ produce el error "*intentando hacer referencia a una función eliminada*". | Esto puede suceder cuando se llama a **make** y el tipo de implementación que pasas como el parámetro de plantilla tiene un constructor `= delete` predeterminado. Edita el archivo de encabezado del tipo de implementación y cambia `= delete` a `= default`. También puedes agregar un constructor al archivo IDL para la clase en tiempo de ejecución. |
| Has implementado [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), pero tus enlaces de XAML no se actualizan (y la interfaz de usuario no se suscribe a [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Recuerda que tienes que establecer `Mode=OneWay` (o TwoWay) en tu expresión de enlace en marcado XAML. Consulta [Controles XAML; enlazar a una propiedad C++/WinRT](binding-property.md) |
| Vas a enlazar un control de elementos XAML a una colección observable, y se produce una excepción en tiempo de ejecución con el mensaje "El parámetro es incorrecto". | En tu IDL e implementación, declara cualquier colección observable como el tipo **Windows.Foundation.Collections.IVector<IInspectable>**. Pero devuelve un objeto que implemente **Windows.Foundation.Collections.IObservableVector<T>**, donde T es tu tipo de elemento. Consulta [Controles de elementos XAML; enlazar a una colección C++/WinRT](binding-collection.md)  |
| El compilador de C++ produce un error del formulario "*'MyImplementationType_base&lt;MyImplementationType&gt;': no hay ningún constructor predeterminado adecuado disponible*".|Esto puede suceder si has derivado de un tipo que tiene un constructor no trivial. Tu constructor del tipo derivado necesita pasar los parámetros que necesita el constructor del tipo base. Para obtener un ejemplo trabajado, consulta [Derivar de un tipo que tiene un constructor no trivial](author-apis.md#deriving-from-a-type-that-has-a-non-trivial-constructor)|
| El compilador de C++ produce el error"*no puede convertirse de 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' a 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Esto puede suceder cuando se pasa un std::vector de std::wstring a una API de Windows Runtime que espera una colección. Para obtener más información, consulta [Tipos de datos C++ estándar y C++/WinRT](std-cpp-data-types.md).|
| El compilador de C++ produce el error"*no puede convertirse de 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' a 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Esto puede suceder cuando se pasa un std::vector de winrt::hstring a una API asincrónica de Windows Runtime que espera una colección, y no has copiado ni movido el vector al destinatario asincrónico. Para obtener más información, consulta [Tipos de datos C++ estándar y C++/WinRT](std-cpp-data-types.md).|
| Al abrir un proyecto, Visual Studio genera el error "*La aplicación del proyecto no está instalada*".|Si no lo has hecho todavía, debes instalar **herramientas de Windows Universal para el desarrollo de C++** desde dentro del diálogo **Nuevo proyecto** de Visual Studio. Si esto no resuelve el problema, el proyecto puede depender de la extensión de Visual Studio (VSIX) C++/WinRT (consulta [Soporte de Visual Studio para C++/WinRT, y VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)).|
| Las pruebas del kit para la certificación de aplicaciones en Windows generan un error indicando que una de tus clases en tiempo de ejecución "*no se deriva de un clase base de Windows. Todas las clases que admiten composición deben, en última instancia, derivar de un tipo en el espacio de nombres de Windows*".|La clase base definitiva de cada clase en tiempo de ejecución *declarada en la aplicación* debe ser un tipo que se origine en un espacio de nombres de Windows*. Puedes derivar un modelo de vista desde [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Como alternativa, declara una clase base enlazable derivada desde **DependencyObject** y deriva tus modelos de vista desde ahí.|
| El compilador de C++ genera un error "*debe ser de tipo WinRT*" para una especialización del delegado EventHandler o TypedEventHandler.|Considera el uso de **winrt::delegate&lt;... T&gt;** en su lugar. Consulta [Crear eventos en C++/WinRT](author-events.md).|
| El compilador de C++ genera un error "*debe ser de tipo WinRT*" para una especialización de la operación asincrónica de Windows Runtime.|Considera volver a una biblioteca de patrones de procesamiento paralelo (PPL) [**task**](https://msdn.microsoft.com/library/hh750113) en su lugar. Consulta [Operaciones simultáneas y asincrónicas](concurrency.md).|
| El compilador de C++ genera "*error C2220: advertencia tratada como error - ningún archivo 'objeto' generado*".|Corregir la advertencia o establece **C/C++** > **General** > **Tratar advertencias como errores** a **No (/WX-)**.|
| Tu aplicación se bloquea porque se llama a un controlador de eventos en tu objeto C++/WinRT después de haber destruido el objeto.|Consulta [Usar el objeto *this* en un controlador de eventos](handle-events.md#using-the-this-object-in-an-event-handler).|
| El compilador de C++ produce "*error C2338: esto es solo para soporte técnico de referencia débil*".|Vas a solicitar una referencia débil de un tipo que pasó la estructura del marcador **winrt::no_weak_ref** como un argumento plantilla a su clase base. Consulta [Rechazar el soporte de referencia débil](weak-references.md#opting-out-of-weak-reference-support)|
| El vinculador C++ produce "*error LNK2019: símbolo externo sin resolver*" para una API desde los encabezados de espacio de nombres de Windows para la proyección C++/WinRT (en el espacio de nombres winrt).|La API se declara más adelante en un encabezado que has incluido, pero su definición se encuentra en un encabezado que no has incluido todavía. Incluye el encabezado nombrado para el espacio de nombres de la API y vuelve a crearlo.|
