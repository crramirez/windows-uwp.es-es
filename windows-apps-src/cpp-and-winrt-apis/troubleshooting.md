---
description: La tabla de solución de problemas de síntomas y soluciones de este tema puede resultarte útil si vas a cortar nuevo código o portar una aplicación existente.
title: Solucionar problemas de C++/WinRT
ms.date: 05/07/2018
ms.topic: article
keywords: windows 10, uwp, estándar, c++, cpp, winrt, proyección, solución de problemas, HRESULT, error
ms.localizationpriority: medium
ms.openlocfilehash: 3158c257738e68d74feefda99a9171d25a63fdde
ms.sourcegitcommit: 2d2483819957619b6de21b678caf887f3b1342af
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/01/2019
ms.locfileid: "9042337"
---
# <a name="troubleshooting-cwinrt-issues"></a>Solucionar problemas de C++/WinRT

> [!NOTE]
> Para obtener información sobre cómo instalar y usar el [C++ / WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) extensión de Visual Studio (VSIX) (que proporciona soporte para plantillas de proyecto) consulta [soporte de Visual Studio para C++ / WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).

Este tema es inicial para que puedas verlo ahora mismo; aunque no lo necesites todavía. La siguiente tabla de solución de problemas de síntomas y soluciones puede resultarte útil si vas a cortar nuevo código o portar una aplicación existente. Si vas a portar y estás deseando seguir avanzando y llegar a la etapa en la que tu proyecto se crea y se ejecuta, puedes progresar temporalmente comentando o anulando cualquier código no esencial que esté causando problemas, y más tarde volver para restaurar lo que has quitado.

Para obtener una lista de preguntas frecuentes, consulte las [preguntas frecuentes](faq.md).

## <a name="tracking-down-xaml-issues"></a>Seguimiento de problemas XAML
Las excepciones de análisis XAML pueden ser difíciles de diagnosticar&mdash;especialmente si no hay ningún mensaje de error significativo dentro de la excepción. Asegúrate de que el depurador está configurado para capturar las primeras excepciones (para probar y capturar la excepción de análisis desde el principio). Podrás inspeccionar la variable de excepción en el depurador para determinar si el mensaje o HRESULT tiene información útil. Asimismo, consulta la ventana de salida de Visual Studio para comprobar si presenta mensajes de error emitidos por el analizador XAML.

Si tu aplicación finaliza y todo lo que sabes es que se ha producido una excepción no controlada durante el análisis de marcado XAML, podría deberse al resultado de una referencia (por clave) a un recurso faltante. O bien, podría tratarse de una excepción dentro de un UserControl, un control personalizado o un panel de diseño personalizado. Un último recurso es una división binaria. Quita aproximadamente la mitad del marcado de una página XAML y vuelve a ejecutar la aplicación. De este modo, sabrás si el error está en a mitad que quitaste (que ahora debes restaurar) o en la mitad que no quitaste. Repite el proceso dividiendo la mitad que contiene el error y así sucesivamente, hasta que reduzcas a cero el problema.

## <a name="symptoms-and-remedies"></a>Síntomas y soluciones
| Síntoma | Solución |
|---------|--------|
| Se produce una excepción en tiempo de ejecución con un valor HRESULT de REGDB_E_CLASSNOTREGISTERED. | Una causa de este error es que no pueda cargarse tu componente de Windows Runtime. Asegúrate de que el archivo de metadatos (`.winmd`) de Windows Runtime del componente tenga el mismo nombre que el binario del componente (el `.dll`), que también es el nombre del proyecto y el nombre del espacio de nombres raíz. Asegúrate también de que el proceso de compilación haya copiado correctamente los metadatos de Windows Runtime y el binario en la carpeta `Appx` de consumo. Y comprueba que el `AppxManifest.xml` de la aplicación de consumo (también en la carpeta `Appx`) contenga un elemento **&lt;InProcessServer&gt;** que declare correctamente la clase activable y el nombre binario. Este error también puede ocurrir si cometes el error de crear instancias de una clase en tiempo de ejecución implementada localmente mediante el constructor predeterminado del tipo proyectado. Consulta [Controles XAML; enlazar a una propiedad C++/WinRT](binding-property.md) para obtener más información sobre cómo utilizar correctamente el tipo proyectado en este caso. |
| El compilador de C++ produce el error "*'implements_type': no es un miembro de ninguna clase base directa o indirecta de '&lt;tipo proyectado&gt;'*". | Esto puede suceder cuando se llama a **make** con el nombre del espacio de nombres no calificado de tu tipo de implementación (**MyRuntimeClass**, por ejemplo), y no has incluido el encabezado de dicho tipo. El compilador interpreta **MyRuntimeClass** como el tipo proyectado. La solución consiste en incluir el encabezado para el tipo de implementación (`MyRuntimeClass.h`, por ejemplo). |
| El compilador de C++ produce el error "*intentando hacer referencia a una función eliminada*". | Esto puede suceder cuando se llama a **make** y el tipo de implementación que pasas como el parámetro de plantilla tiene un constructor `= delete` predeterminado. Edita el archivo de encabezado del tipo de implementación y cambia `= delete` a `= default`. También puedes agregar un constructor al archivo IDL para la clase en tiempo de ejecución. |
| Has implementado [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), pero tus enlaces de XAML no se actualizan (y la interfaz de usuario no se suscribe a [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Recuerda que tienes que establecer `Mode=OneWay` (o TwoWay) en tu expresión de enlace en marcado XAML. Consulta [Controles XAML; enlazar a una propiedad C++/WinRT](binding-property.md) |
| Vas a enlazar un control de elementos XAML a una colección observable, y se produce una excepción en tiempo de ejecución con el mensaje "El parámetro es incorrecto". | En tu IDL e implementación, declara cualquier colección observable como el tipo **Windows.Foundation.Collections.IVector<IInspectable>**. Pero devuelve un objeto que implemente **Windows.Foundation.Collections.IObservableVector<T>**, donde T es tu tipo de elemento. Consulta [Controles de elementos XAML; enlazar a una colección C++/WinRT](binding-collection.md)  |
| El compilador de C++ produce un error del formulario "*'MyImplementationType_base&lt;MyImplementationType&gt;': no hay ningún constructor predeterminado adecuado disponible*".|Esto puede suceder si has derivado de un tipo que tiene un constructor no trivial. Tu constructor del tipo derivado necesita pasar los parámetros que necesita el constructor del tipo base. Para obtener un ejemplo trabajado, consulta [Derivar de un tipo que tiene un constructor no trivial](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor)|
| El compilador de C++ produce el error"*no puede convertirse de 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' a 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Esto puede suceder cuando se pasa un std::vector de std::wstring a una API de Windows Runtime que espera una colección. Para obtener más información, consulta [Tipos de datos C++ estándar y C++/WinRT](std-cpp-data-types.md).|
| El compilador de C++ produce el error"*no puede convertirse de 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' a 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Esto puede suceder cuando se pasa un std::vector de winrt::hstring a una API asincrónica de Windows Runtime que espera una colección, y no has copiado ni movido el vector al destinatario asincrónico. Para obtener más información, consulta [Tipos de datos C++ estándar y C++/WinRT](std-cpp-data-types.md).|
| Al abrir un proyecto, Visual Studio genera el error "*La aplicación del proyecto no está instalada*".|Si no lo has hecho todavía, debes instalar **herramientas de Windows Universal para el desarrollo de C++** desde dentro del diálogo **Nuevo proyecto** de Visual Studio. Si esto no resuelve el problema, a continuación, el proyecto puede depender de C++ / extensión de Visual Studio (VSIX) de WinRT (consulta [soporte de Visual Studio para C++ / WinRT](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-xaml-the-vsix-extension-and-the-nuget-package).|
| Las pruebas del kit para la certificación de aplicaciones en Windows generan un error indicando que una de tus clases en tiempo de ejecución "*no se deriva de un clase base de Windows. Todas las clases que admiten composición deben, en última instancia, derivar de un tipo en el espacio de nombres de Windows*".|Cualquier clase en tiempo de ejecución (que se declara en la aplicación) que se deriva de una clase base se conoce como un *las* clases. La clase base definitiva de una clase puede componer debe ser un tipo que se origine en un espacio de nombres Windows.*; Por ejemplo, [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Consulta [controles XAML; enlazar a C++ / WinRT propiedad](binding-property.md) para obtener más detalles.|
| El compilador de C++ genera un error "*debe ser de tipo WinRT*" para una especialización del delegado EventHandler o TypedEventHandler.|Considera el uso de **winrt::delegate&lt;... T&gt;** en su lugar. Consulta [Crear eventos en C++/WinRT](author-events.md).|
| El compilador de C++ genera un error "*debe ser de tipo WinRT*" para una especialización de la operación asincrónica de Windows Runtime.|Considera volver a una biblioteca de patrones de procesamiento paralelo (PPL) [**task**](https://msdn.microsoft.com/library/hh750113) en su lugar. Consulta [Operaciones simultáneas y asincrónicas](concurrency.md).|
| El compilador de C++ genera "*error C2220: advertencia tratada como error - ningún archivo 'objeto' generado*".|Corregir la advertencia o establece **C/c ++**>**General**>**Tratar advertencias como errores** a **No (/ WX-)**.|
| Tu aplicación se bloquea porque se llama a un controlador de eventos en tu objeto C++/WinRT después de haber destruido el objeto.|Vea de [forma segura obtener acceso a *este* puntero con un delegado de controlador de eventos](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).|
| El compilador de C++ produce "*error C2338: esto es solo para soporte técnico de referencia débil*".|Vas a solicitar una referencia débil de un tipo que pasó la estructura del marcador **winrt::no_weak_ref** como un argumento plantilla a su clase base. Consulta [Rechazar el soporte de referencia débil](weak-references.md#opting-out-of-weak-reference-support).|
| El vinculador C++ produce "*error LNK2019: símbolo externo sin resolver*"|Consulta [por qué el enlazador que me un "error LNK2019: símbolo externo sin resolver" error?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).|
| La cadena de herramientas LLVM y Clang produce errores cuando se usan con C++ / WinRT.|No admitimos la cadena de herramientas LLVM y Clang para C++ / WinRT, pero si quisieras emular cómo usamos internamente, a continuación, se podría intentar un experimento, como el que se describe en [¿puedo usar LLVM/Clang para compilar con C++ / WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).|
| El compilador de C++ produce "*ningún constructor predeterminado adecuado disponible*" de un tipo proyectado. | Si intentas para retrasar la inicialización de un objeto de clase en tiempo de ejecución, o consumir e implementar una clase en tiempo de ejecución en el mismo proyecto, a continuación, deberás llamar a la `nullptr_t` constructor. Para obtener más información, consulta [Consumir API con C++/WinRT](consume-apis.md). |
| El compilador de C++ produce "*error C3861: 'from_abi': no se encontró el identificador*" y otros errores que se origine en *base.h*. Es posible que veas este error si estás usando Visual Studio 2017 (versión 15.8.0 o posterior) y el destino de Windows SDK versión 10.0.17134.0 (Windows 10, versión 1803). | Ya sea destino una posterior (más compatible) versión del SDK de Windows, o la propiedad de proyecto de conjunto de **C/c ++** > **idioma** > **Conformance mode: No** (Además, si **/ permissive-** aparece en la propiedad de proyecto **C o C++**  >  **Idioma** > de**línea de comandos** en **Las opciones adicionales**, elimínalo). |
| El compilador de C++ produce "*error C2039: 'IUnknown': no es un miembro de ' espacio de nombres \'global''*". | Consulta [cómo redestinar tu C++ / WinRT proyecto a una versión posterior del Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| El vinculador C++ produce "*error LNK2019: símbolo externo sin resolver _WINRT_CanUnloadNow@0 hace referencia en la función _VSDesignerCanUnloadNow@0 *" | Consulta [cómo redestinar tu C++ / WinRT proyecto a una versión posterior del Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk). |
| El proceso de compilación genera el mensaje de error *The c++ / WinRT VSIX ya no proporciona soporte técnico de compilación del proyecto.  Por favor, agrega una referencia de proyecto para el paquete de Microsoft.Windows.CppWinRT Nuget*. | Instalar el paquete de NuGet **Microsoft.Windows.CppWinRT** en el proyecto. Para obtener más información, consulta [las versiones anteriores de la extensión VSIX](intro-to-using-cpp-with-winrt.md#earlier-versions-of-the-vsix-extension). |

> [!NOTE]
> Si en este tema no responde a tu pregunta, a continuación, puedes buscar ayuda visitando la [Comunidad de desarrolladores de Visual Studio C++](https://developercommunity.visualstudio.com/spaces/62/index.html), o mediante el [ `c++-winrt` etiqueta en Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
