---
author: stevewhims
description: La tabla de solución de problemas de síntomas y soluciones de este tema puede resultarte útil si vas a cortar nuevo código o portar una aplicación existente.
title: Solucionar problemas de C++/WinRT
ms.author: stwhi
ms.date: 05/07/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp, estándar, c++, cpp, winrt, proyección, solución de problemas, HRESULT, error
ms.localizationpriority: medium
ms.openlocfilehash: cccc58c0b9dd5f922c87d3e6860bb2f2045ea767
ms.sourcegitcommit: a160b91a554f8352de963d9fa37f7df89f8a0e23
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/21/2018
ms.locfileid: "4128344"
---
# <a name="troubleshooting-cwinrtwindowsuwpcpp-and-winrt-apisintro-to-using-cpp-with-winrt-issues"></a>Solucionar problemas de [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt)
> [!NOTE]
> Para obtener información sobre la instalación y uso de la extensión de Visual Studio (VSIX) de C++/WinRT (la cual ofrece soporte para plantillas de proyectos, así como propiedades y destinos de MSBuild de C++/WinRT), consulta el [Soporte de Visual Studio para C++/WinRT y VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).

Este tema es inicial para que puedas verlo ahora mismo; aunque no lo necesites todavía. La siguiente tabla de solución de problemas de síntomas y soluciones puede resultarte útil si vas a cortar nuevo código o portar una aplicación existente. Si vas a portar y estás deseando seguir avanzando y llegar a la etapa en la que tu proyecto se crea y se ejecuta, puedes progresar temporalmente comentando o anulando cualquier código no esencial que esté causando problemas, y más tarde volver para restaurar lo que has quitado.

Para obtener una lista de preguntas frecuentes, consulta [preguntas frecuentes](faq.md).

## <a name="tracking-down-xaml-issues"></a>Seguimiento de problemas XAML
Las excepciones de análisis XAML pueden ser difíciles de diagnosticar&mdash;especialmente si no hay ningún mensaje de error significativo dentro de la excepción. Asegúrate de que el depurador está configurado para capturar las primeras excepciones (para probar y capturar la excepción de análisis desde el principio). Podrás inspeccionar la variable de excepción en el depurador para determinar si el mensaje o HRESULT tiene información útil. Asimismo, consulta la ventana de salida de Visual Studio para comprobar si presenta mensajes de error emitidos por el analizador XAML.

Si tu aplicación finaliza y todo lo que sabes es que se ha producido una excepción no controlada durante el análisis de marcado XAML, podría deberse al resultado de una referencia (por clave) a un recurso faltante. O bien, podría tratarse de una excepción dentro de un UserControl, un control personalizado o un panel de diseño personalizado. Un último recurso es una división binaria. Quita aproximadamente la mitad del marcado de una página XAML y vuelve a ejecutar la aplicación. De este modo, sabrás si el error está en a mitad que quitaste (que ahora debes restaurar) o en la mitad que no quitaste. Repite el proceso dividiendo la mitad que contiene el error y así sucesivamente, hasta que reduzcas a cero el problema.

## <a name="symptoms-and-remedies"></a>Síntomas y soluciones
| Síntoma | Solución |
|---------|--------|
| Se produce una excepción en tiempo de ejecución con un valor HRESULT de REGDB_E_CLASSNOTREGISTERED. | Una causa de este error es que no pueda cargarse tu componente de Windows Runtime. Asegúrate de que el archivo de metadatos (`.winmd`) de Windows Runtime del componente tenga el mismo nombre que el binario del componente (el `.dll`), que también es el nombre del proyecto y el nombre del espacio de nombres raíz. Asegúrate también de que el proceso de compilación haya copiado correctamente los metadatos de Windows Runtime y el binario en la carpeta `Appx` de consumo. Y comprueba que el `AppxManifest.xml` de la aplicación de consumo (también en la carpeta `Appx`) contenga un elemento **&lt;InProcessServer&gt;** que declare correctamente la clase activable y el nombre binario. Este error también puede ocurrir si cometes el error de crear instancias de una clase en tiempo de ejecución implementada localmente mediante el constructor predeterminado del tipo proyectado. Consulta [Controles XAML; enlazar a una propiedad C++/WinRT](binding-property.md) para obtener más información sobre cómo utilizar correctamente el tipo proyectado en este caso. |
| El compilador de C++ produce el error "*'implements_type': no es un miembro de ninguna clase base directa o indirecta de '&lt;tipo proyectado&gt;'*". | Esto puede suceder cuando se llama a **make** con el nombre del espacio de nombres no calificado de tu tipo de implementación (**MyRuntimeClass**, por ejemplo), y no has incluido el encabezado de dicho tipo. El compilador interpreta **MyRuntimeClass** como el tipo proyectado. La solución consiste en incluir el encabezado para el tipo de implementación (`MyRuntimeClass.h`, por ejemplo). |
| El compilador de C++ produce el error "*intentando hacer referencia a una función eliminada*". | Esto puede suceder cuando se llama a **make** y el tipo de implementación que pasas como el parámetro de plantilla tiene un constructor `= delete` predeterminado. Edita el archivo de encabezado del tipo de implementación y cambia `= delete` a `= default`. También puedes agregar un constructor al archivo IDL para la clase en tiempo de ejecución. |
| Has implementado [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), pero tus enlaces de XAML no se actualizan (y la interfaz de usuario no se suscribe a [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)). | Recuerda que tienes que establecer `Mode=OneWay` (o TwoWay) en tu expresión de enlace en marcado XAML. Consulta [Controles XAML; enlazar a una propiedad C++/WinRT](binding-property.md) |
| Vas a enlazar un control de elementos XAML a una colección observable, y se produce una excepción en tiempo de ejecución con el mensaje "El parámetro es incorrecto". | En tu IDL e implementación, declara cualquier colección observable como el tipo **Windows.Foundation.Collections.IVector<IInspectable>**. Pero devuelve un objeto que implemente **Windows.Foundation.Collections.IObservableVector<T>**, donde T es tu tipo de elemento. Consulta [Controles de elementos XAML; enlazar a una colección C++/WinRT](binding-collection.md)  |
| El compilador de C++ produce un error del formulario "*'MyImplementationType_base&lt;MyImplementationType&gt;': no hay ningún constructor predeterminado adecuado disponible*".|Esto puede suceder si has derivado de un tipo que tiene un constructor no trivial. Tu constructor del tipo derivado necesita pasar los parámetros que necesita el constructor del tipo base. Para obtener un ejemplo trabajado, consulta [Derivar de un tipo que tiene un constructor no trivial](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor)|
| El compilador de C++ produce el error"*no puede convertirse de 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' a 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Esto puede suceder cuando se pasa un std::vector de std::wstring a una API de Windows Runtime que espera una colección. Para obtener más información, consulta [Tipos de datos C++ estándar y C++/WinRT](std-cpp-data-types.md).|
| El compilador de C++ produce el error"*no puede convertirse de 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' a 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".|Esto puede suceder cuando se pasa un std::vector de winrt::hstring a una API asincrónica de Windows Runtime que espera una colección, y no has copiado ni movido el vector al destinatario asincrónico. Para obtener más información, consulta [Tipos de datos C++ estándar y C++/WinRT](std-cpp-data-types.md).|
| Al abrir un proyecto, Visual Studio genera el error "*La aplicación del proyecto no está instalada*".|Si no lo has hecho todavía, debes instalar **herramientas de Windows Universal para el desarrollo de C++** desde dentro del diálogo **Nuevo proyecto** de Visual Studio. Si esto no resuelve el problema, el proyecto puede depender de la extensión de Visual Studio (VSIX) C++/WinRT (consulta [Soporte de Visual Studio para C++/WinRT, y VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)).|
| Las pruebas del kit para la certificación de aplicaciones en Windows generan un error indicando que una de tus clases en tiempo de ejecución "*no se deriva de un clase base de Windows. Todas las clases que admiten composición deben, en última instancia, derivar de un tipo en el espacio de nombres de Windows*".|Cualquier clase en tiempo de ejecución (que se declara en la aplicación) que se deriva de una clase base se conoce como un *ajustable* clase. La clase base definitiva de una clase puede componer debe ser un tipo que se origine en un espacio de nombres Windows *; Por ejemplo, [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject). Consulta [controles XAML; enlazar a C++ / WinRT propiedad](binding-property.md) para obtener más detalles.|
| El compilador de C++ genera un error "*debe ser de tipo WinRT*" para una especialización del delegado EventHandler o TypedEventHandler.|Considera el uso de **winrt::delegate&lt;... T&gt;** en su lugar. Consulta [Crear eventos en C++/WinRT](author-events.md).|
| El compilador de C++ genera un error "*debe ser de tipo WinRT*" para una especialización de la operación asincrónica de Windows Runtime.|Considera volver a una biblioteca de patrones de procesamiento paralelo (PPL) [**task**](https://msdn.microsoft.com/library/hh750113) en su lugar. Consulta [Operaciones simultáneas y asincrónicas](concurrency.md).|
| El compilador de C++ genera "*error C2220: advertencia tratada como error - ningún archivo 'objeto' generado*".|Corregir la advertencia o establece **C/C++** > **General** > **Tratar advertencias como errores** a **No (/WX-)**.|
| Tu aplicación se bloquea porque se llama a un controlador de eventos en tu objeto C++/WinRT después de haber destruido el objeto.|Consulta [Usar el objeto *this* en un controlador de eventos](handle-events.md#using-the-this-object-in-an-event-handler).|
| El compilador de C++ produce "*error C2338: esto es solo para soporte técnico de referencia débil*".|Vas a solicitar una referencia débil de un tipo que pasó la estructura del marcador **winrt::no_weak_ref** como un argumento plantilla a su clase base. Consulta [Rechazar el soporte de referencia débil](weak-references.md#opting-out-of-weak-reference-support)|
| El vinculador C++ produce "*error LNK2019: símbolo externo sin resolver*"|Consulta [¿por qué el enlazador que me un "error LNK2019: símbolo externo sin resolver" error?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error)|
| La cadena de herramientas LLVM y Clang produce errores cuando se usa con C++ / WinRT.|No admitimos la cadena de herramientas LLVM y Clang para C++ / WinRT, pero si quisieras emular cómo usamos internamente, a continuación, se podría intentar un experimento, como el que se describe en [puedo usar LLVM/Clang para compilar con C++ / WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).|
| El compilador de C++ produce "*ningún constructor predeterminado adecuado disponible*" de un tipo proyectado. | Si estás intentando para retrasar la inicialización de un objeto de clase en tiempo de ejecución, o consumir e implementar una clase en tiempo de ejecución en el mismo proyecto, a continuación, deberás llamar a la `nullptr_t` constructor. Para obtener más información, consulta [Consumir API con C++/WinRT](consume-apis.md). |
| El compilador de C++ produce "*error C3861: 'from_abi': no se encontró el identificador*" y otros errores que se origine en *base.h*. Es posible que veas este error si estás usando Visual Studio 2017 (versión 15.8.0 o posterior) y destinada a Windows SDK versión 10.0.17134.0 (Windows 10, versión 1803). | Ya sea destinados a un posterior (más compatible) versión del SDK de Windows o la propiedad de proyecto de conjunto de **C/c ++** > **idioma** > **Conformance mode: No** (Además, si **/ permissive-** aparece en la propiedad de proyecto **C o C++**  >  **Idioma** > de**línea de comandos** en **Las opciones adicionales**, elimínalo). |

> [!NOTE]
> Si en este tema no responde a tu pregunta, puedes buscar ayuda mediante la [etiqueta `c++-winrt` en Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).
