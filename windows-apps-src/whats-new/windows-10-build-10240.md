---
Description: La compilación 10240 de Windows 10 y las actualizaciones de herramientas para desarrolladores siguen proporcionando herramientas, características y experiencias con la tecnología de la Plataforma universal de Windows.
title: Novedades de la compilación 10240 de Windows 10; julio de 2015
keywords: conoce las novedades, novedades, actualizar, actualización, actualizaciones, características, nuevo, Windows 10, 1507, 10240
ms.date: 11/02/2017
ms.topic: article
ms.assetid: 4853e55b-2232-4589-903a-ccb60e07aeb8
ms.localizationpriority: medium
ms.openlocfilehash: bfd67fd6a1ff442e2a40a99a765c006b570080ec
ms.sourcegitcommit: aaa4b898da5869c064097739cf3dc74c29474691
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 06/13/2019
ms.locfileid: "66372023"
---
# <a name="whats-new-in-windows10-for-developers-build-10240"></a>Novedades para desarrolladores en Windows 10, compilación 10240

Tanto la compilación 10240 de Windows 10 como el SDK actualizado proporcionan las herramientas, características y experiencias necesarias para crear aplicaciones excepcionales de la Plataforma universal de Windows. Después de [instalar las herramientas y el SDK](https://go.microsoft.com/fwlink/?LinkId=821431) en Windows 10, estarás listo para [crear una nueva aplicación universal de Windows](../get-started/create-uwp-apps.md) o para explorar cómo puedes usar tu [código de aplicación existente en Windows](../porting/index.md).

Aquí podrás echar un vistazo a las novedades de cada característica de la compilación 10240 de Windows 10 (también conocida como Windows 10 versión 1507).

## <a name="adaptive-layouts"></a>Diseños adaptables

Característica | Descripción
 :---- | ----:
Varias vistas de contenido personalizado | XAML ofrece nueva compatibilidad para definir vistas adaptadas (archivos .xaml) que comparten el mismo archivo de código. Esto facilita la creación y el mantenimiento de diferentes vistas adaptadas a un escenario o una familia de dispositivos específicos. Si la aplicación tiene distintos modelos de navegación, diseño o contenido de interfaz de usuario que son drásticamente diferentes para diversos escenarios, crea varias vistas. Por ejemplo, podrías usar un [Pivot](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.Pivot) con navegación optimizada para usar tu aplicación móvil con una sola mano y usar una [SplitView](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.SplitView) con un menú de navegación optimizado para el mouse en tu aplicación de escritorio.
StateTriggers | Mediante la nueva función [VisualState.StateTriggers](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstate.statetriggers), puedes establecer de manera condicional propiedades en función del alto o el ancho de ventana o en función de un desencadenador personalizado. Antes tenías que controlar los eventos [SizeChanged](https://docs.microsoft.com/uwp/api/windows.ui.xaml.window.sizechanged) de Windows en código y llamar a [VisualStateManager.GotoState](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstatemanager.gotostate).
Establecedores | Mediante la nueva sintaxis de [VisualState.Setters](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstate.setters), puedes usar marcado simplificado para definir cambios de propiedad en [VisualStateManager](https://docs.microsoft.com/uwp/api/windows.ui.xaml.visualstatemanager). Antes, tenías que usar un guion gráfico y crear animaciones para aplicar cambios de propiedad, como el cambio de la orientación de un [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) de Horizontal a Vertical. En las aplicaciones universales de Windows, puedes usar esta sintaxis de Setter más sencilla: <setter target="stackPanel1.Orientation" value="Vertical" />


## <a name="xaml-features"></a>Funciones XAML

Característica | Descripción
 :---- | :----
Enlaces de datos compilados (x:Bind) | En las aplicaciones universales de Windows, puedes usar el nuevo mecanismo de enlace basado en el compilador habilitado por la propiedad x:Bind. Los enlaces basados en el compilador están fuertemente tipados y se procesan en tiempo de compilación, lo que resulta más rápido y ofrece errores en tiempo de compilación cuando no coinciden los tipos de enlace. Y dado que los enlaces se traducen al código de la aplicación compilada, ahora puedes depurar enlaces recorriendo el código de Visual Studio para diagnosticar problemas de enlace específicos. También puedes usar x:Bind para enlazar a un método, como este: <textblock text="{x:Bind Customer.Address.ToString()}" /> Para escenarios de enlace típicos, puedes usar x:Bind en lugar de Binding y obtener un mejor rendimiento y mantenimiento.
Representación incremental declarativa de listas (x:Phase) | En las aplicaciones universales de Windows, el nuevo atributo x:Phase permite realizar la representación incremental, o en fases, de listas con XAML en lugar de código. Al moverse en el modo panorámico en largas listas con elementos complejos, es posible que tu aplicación no pueda representar elementos lo suficientemente rápido como para igualar la velocidad de movimiento panorámico, lo que hará que la experiencia de los usuarios sea mala. La representación por fases permite especificar la prioridad de representación de los elementos individuales en un elemento de lista, por lo que únicamente las partes más importantes del elemento de lista se representan en escenarios de movimiento panorámico rápido. Esto produce una experiencia más uniforme de movimiento panorámico para el usuario. <br /><br /> En Windows 8.1, puedes controlar el evento [ContainerContentChanging](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging) y escribir código para representar elementos de lista en fases. En las aplicaciones para UWP, puedes realizar la representación en fases mediante declaración con el atributo x:Phase. Usado junto con x:Bind de enlaces compilados, x:Phase permite especificar con facilidad una prioridad de representación para cada elemento enlazado de una plantilla de datos. Al desplazarse en movimiento panorámico, el trabajo para representar elementos se divide por tiempo en función de la fase, lo que permite la representación de elementos incremental.
Carga aplazada de elementos de la interfaz de usuario (x:deferLoadstrategy) | En las aplicaciones universales de Windows, la nueva directiva x:deferLoadstrategy te permite especificar la carga retrasada de partes de la interfaz de usuario, lo que mejora el rendimiento de inicio y reduce el uso de memoria de la aplicación. Por ejemplo, si la interfaz de usuario de la aplicación tiene un elemento para la validación de datos que se muestra únicamente cuando se escriben datos incorrectos, puede retrasar la carga de ese elemento hasta que se necesite. A continuación, los objetos del elemento no se crean cuando se carga la página; en su lugar, se crean solo cuando hay un error de datos y es necesario agregarlos al árbol visual de la página.
SplitView | El nuevo control [SplitView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.splitview) te ofrece una forma de mostrar y ocultar con facilidad contenido transitorio. Normalmente se usa para escenarios de navegación de nivel superior como el "menú hamburguesa", donde el contenido de la navegación se oculta y se desliza cuando sea necesario como resultado de una acción del usuario.
RelativePanel | [RelativePanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.relativepanel) es un nuevo panel de diseño que te permite colocar y alinear objetos secundarios relacionados entre sí o con el panel primario. Por ejemplo, puedes especificar que siempre se debe colocar texto en el lado izquierdo del panel y que un botón siempre se debe alinear debajo del texto. Usa ReleativePanel al crear interfaces de usuario que no tengan un patrón lineal claro que llamaría para usar un [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) o [Grid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.grid).
CalendarView | El control [CalendarView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.calendarview) facilita el proceso de ver y seleccionar fechas e intervalos de fechas mediante una vista mensual y personalizable. CalendarView admite funciones como las fechas mínima, máxima y sin disponibilidad para limitar qué fechas se pueden seleccionar. También puedes configurar barras de densidad personalizadas que se pueden usar para mostrar lo que se ha completado de manera general de la programación en un día concreto.
CalendarDatePicker | [CalendarDatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.calendardatepicker) es un control desplegable que está optimizado para seleccionar una fecha determinada del CalendarView en que la información contextual es importante; por ejemplo, el día de la semana o lo que se ha completado del calendario. Es similar al control [DatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepicker), pero el DatePicker está optimizado para seleccionar una fecha conocida, como una fecha de nacimiento.
MediaTransportControls | La nueva clase [MediaTransportControls](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediatransportcontrols) facilita al personalización de los controles de transporte de un [MediaElement](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement). En Windows 8.1, podrías habilitar los controles de transporte integrados de MediaElement o crear tus propios controles de transporte que llaman a métodos de MediaElement. Ahora puedes usar la funcionalidad integrada de MediaTransportControls y seguir personalizando con facilidad el aspecto para adaptar tu aplicación.
Notificaciones de cambio de propiedad | En las aplicaciones universales de Windows, puedes escuchar los cambios de propiedad en DependencyObjects, incluso para las propiedades que no tienen eventos de cambio correspondientes. Las notificaciones actúan como un evento, pero realmente se exponen como una devolución de llamada. La devolución de llamada toma un argumento de remitente como un controlador de eventos, pero no toma un argumento de evento. En su lugar, solamente se pasa el identificador de la propiedad para indicar la propiedad. Con esta información la aplicación puede definir un solo controlador para las notificaciones de varias propiedades. Para obtener más información, consulta [RegisterPropertyChangedCallback](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dependencyobject.registerpropertychangedcallback) y [UnregisterPropertyChangedCallback](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dependencyobject.unregisterpropertychangedcallback).
Maps | La clase [MapControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps.mapcontrol) se ha actualizado para ofrecer imágenes aéreas en 3D y vistas de nivel de calle. Estas nuevas características y las funcionalidades de mapas anteriores ahora están disponibles para las aplicaciones universales de Windows. Agrega mapas a la aplicación con las siguientes API: [Windows.UI.Xaml.Controls.Maps](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps) y [Windows.Services.Maps](https://docs.microsoft.com/uwp/api/windows.services.maps). Para empezar a usar ya estas API en una aplicación universal de Windows, solicita una clave desde el [Centro para desarrolladores de Mapas de Bing](https://www.bingmapsportal.com/). Para obtener más información, consulta [Cómo autenticar una aplicación de Mapas](https://docs.microsoft.com/previous-versions/windows/apps/dn741528(v=win.10)). Otra novedad de Windows 10 es que los usuarios de PC y teléfonos pueden descargar mapas sin conexión desde la aplicación Configuración. Si están disponibles, los mapas sin conexión se usan mediante [MapControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.maps.mapcontrol) para mostrar mapas cuando no se dispone de acceso a Internet.
Asignación de botón de entrada | La clase [Windows.UI.Xaml.Input.KeyEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs) tiene una nueva propiedad [OriginalKey](https://docs.microsoft.com/uwp/api/windows.ui.xaml.input.keyroutedeventargs.originalkey) que, junto con su actualización correspondiente a [Windows.System.VirtualKey](https://docs.microsoft.com/uwp/api/windows.system.virtualkey), te permite obtener el botón de entrada original sin asignar asociado al evento de entrada de teclado.
Entrada manuscrita | Actualmente, es más fácil usar las funciones sólidas de entrada manuscrita en aplicaciones de Windows en tiempo de ejecución con C++, C# o Visual Basic, gracias al control [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas) y las clases subyacentes de [InkPresenter](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkpresenter). El control [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas) define un área de superposición para dibujar y representar trazos de lápiz. La funcionalidad de este control (entrada, procesamiento y representación) procede de las clases [InkPresenter](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkpresenter), [InkStroke](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkstroke), [InkRecognizers](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inkrecognizer) e [InkSynchronizer](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.inksynchronizer). **Importante:** Estas clases no se admiten en aplicaciones de Windows que usan JavaScript.


## <a name="updated-xaml-features"></a>Funciones XAML actualizadas

Característica | Descripción
 :---- | :----
Actualizaciones de CommandBar y AppBar | Los controles [CommandBar](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.commandbar) y [AppBar](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbar) se han actualizado para tener una API, un comportamiento y una experiencia del usuario coherentes para aplicaciones para UWP en todas las familias de dispositivos. <br /><br />El control CommandBar para aplicaciones universales de Windows se ha mejorado para ofrecer un superconjunto de funciones de AppBar y una mayor flexibilidad en la manera en que puedes usarlo en la aplicación. Deberías usar CommandBar para todas las nuevas aplicaciones universales de Windows en Windows 10. En un control CommandBar en Windows 8.1, podrías usar solo controles que implementan [ICommandBarElement](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.icommandbarelement), como [AppBarButton](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbarbutton). En las aplicaciones universales de Windows, ahora puedes incluir contenido personalizado en CommandBar además de AppBarButtons. <br /><br />Se ha actualizado el control de AppBar para que puedas mover con mayor facilidad las aplicaciones de Windows 8.1 que usan AppBar para la Plataforma universal de Windows. AppBar se diseñó para su uso con aplicaciones de pantalla completa y para invocarse con gestos de borde. Se ha actualizado la cuenta de controles para problemas como las aplicaciones con ventana y la falta de gestos de borde en Windows 10. <br /><br />El [AppBar.ClosedDisplayMode oculto](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.appbar.closeddisplaymode), anteriormente solo en Windows Phone, se admite ahora en todas las familias de dispositivos, lo que te permite elegir entre diferentes niveles de sugerencias para comandos. AppBar muestra una sugerencia mínima de forma predeterminada para ofrecerte coherencia al actualizar las aplicaciones de Windows 8.1 a aplicaciones universales de Windows en las que ya no puedes confiar en la compatibilidad de gestos de borde de la plataforma.
Actualizaciones de GridView | Antes de Windows 10, la orientación de diseño GridView predeterminada era horizontal en Windows y vertical en Windows Phone. En las aplicaciones para UWP, GridView usa un diseño vertical de manera predeterminada para todas las familias de dispositivos a fin de garantizar que tengas una experiencia predeterminada coherente.
Propiedad AreStickyGroupHeadersEnabled | Cuando muestras datos agrupados en un control [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) o [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview), los encabezados de grupo ahora permanecen visibles cuando se desplaza la lista. Esto es importante en grandes conjuntos de datos donde el encabezado ofrece contexto para los datos que el usuario está viendo. Sin embargo, en casos donde solo hay algunos elementos en cada grupo, es posible que quieras que los encabezados se desplacen fuera de la pantalla con los elementos. Puedes establecer la propiedad AreStickyGroupHeadersEnabled en [ItemsStackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemsstackpanel) e [ItemsWrapGrid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemswrapgrid) para controlar este comportamiento.
Método GroupHeaderContainerFromItemContainer | Cuando muestras datos agrupados en un [ItemsControl](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemscontrol), puedes llamar al método [GroupHeaderContainerFromItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.itemscontrol.groupheadercontainerfromitemcontainer) para obtener una referencia al encabezado de elemento principal para el grupo. Por ejemplo, si un usuario elimina el último elemento de un grupo, puedes obtener una referencia al encabezado del grupo y quitar tanto el elemento como el encabezado del grupo a la vez.
Evento ChoosingGroupHeaderContainer | El nuevo evento [ChoosingGroupHeaderContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosinggroupheadercontainer) en [ListViewBase](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase) te permite establecer el estado en los encabezados de grupo en un control ListView o GridView. Por ejemplo, puedes controlar este evento para establecer la [AutomationProperties.Nameproperty](https://docs.microsoft.com/uwp/api/windows.ui.xaml.automation.automationproperties.nameproperty) en el encabezado del grupo para que represente el grupo en las tecnologías de ayuda.
Evento ChoosingItemContainer | El nuevo evento [ChoosingItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer) en ListViewBase te ofrece un mayor control sobre la virtualización de la interfaz de usuario en un [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) o [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview). Usa este evento junto con el evento [ContainerContentChanging](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.containercontentchanging) para mantener tu propia cola de contenedores reciclados a la que recurrir según sea necesario. Por ejemplo, si el origen de datos se ha restablecido debido al filtrado, puedes hacer coincidir rápidamente un conjunto de elementos visuales (ItemContainers) ya creados con sus datos para lograr un rendimiento óptimo.
Virtualización de desplazamiento de la lista |Los controles [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) y [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) en XAML tienen un nuevo evento [ListViewBase.ChooseingItemContainer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.choosingitemcontainer) que mejora el rendimiento del control cuando se produce un cambio en la colección de datos. En lugar de realizar un restablecimiento completo de la lista, en el que se reproduce la animación de entrada, el sistema ahora mantiene los elementos actuales de la vista, junto con el estado de selección y enfoque; los elementos nuevos y quitados de la ventanilla aparecen y desaparecen sin problemas. Después de realizar un cambio en la colección de datos en la que los contenedores no se destruyen, una aplicación puede relacionar rápidamente cualquier elemento "antiguo" con su contenedor previo y omitir el procesamiento posterior de los métodos de invalidación del ciclo de vida del contenedor. Solo los elementos "nuevos" se procesan y se asocian a los contenedores reciclados o nuevos.
Método SelectRange y propiedad SelectedRanges | En aplicaciones universales de Windows, los controles [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) y [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) ahora permiten seleccionar elementos en términos de rangos de índices de elementos en lugar de referencias de objetos de elementos. Esta es una manera más eficaz de describir la selección de elementos porque los objetos de elementos no se tienen que crear para cada elemento seleccionado. Para obtener más información, consulta [ListViewBase.SelectedRanges](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.selectedranges), [ListViewBase.SelectRange](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.selectrange) y [ListViewBase.DeselectRange](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.deselectrange).
Nuevas API de ListViewItemPresenter | [ListView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listview) y [GridView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.gridview) usan presentadores de elementos para proporcionar los elementos visuales predeterminados para selección y foco. En las aplicaciones para UWP, [ListViewItemPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.listviewitempresenter) y [GridViewItemPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.primitives.gridviewitempresenter) tienen propiedades nuevas que te permiten personalizar aún más los elementos visuales para los elementos de lista. Las nuevas propiedades son CheckBoxBrush, CheckMode, FocusSecondaryBorderBrush, PointerOverForeground, PressedBackground y SelectedPressedBackground.
Actualizaciones de SemanticZoom | El control [SemanticZoom](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.semanticzoom) tiene ahora un comportamiento coherente para las aplicaciones para UWP entre todas las familias de dispositivos. La acción predeterminada para cambiar entre la vista acercada y la vista alejada es pulsar en un encabezado de grupo en la vista acercada. Esto es lo mismo que el comportamiento en Windows Phone 8.1, pero supone un cambio respecto a Windows 8.1, que usaba el gesto de reducir para hacer zoom. Para cambiar las vistas mediante reducir para acercar, establece [ScrollViewer.ZoomMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.zoommode)="Enabled" en el ScrollViewer interno de SemanticZoom. <br /><br />En las aplicaciones universales de Windows, la vista alejada reemplaza la vista acercada y tiene el mismo tamaño que la vista que reemplazó. Este es el mismo comportamiento que en Windows 8.1, pero supone un cambio respecto a Windows Phone 8.1, donde la vista alejada ocupaba todo el tamaño de la pantalla y se representaba encima de todo el resto del contenido.
Actualizaciones de DatePicker y TimePicker | Los controles [DatePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepicker) y [TimePicker](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.timepicker) ahora tienen una implementación coherente para las aplicaciones universales de Windows en todas las familias de dispositivos. También tienen un nuevo aspecto para Windows 10. La parte emergente del control ahora usa los controles [DatePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.datepickerflyout) y [TimePickerFlyout](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.timepickerflyout) en todos los dispositivos. Este es el mismo comportamiento que en Windows Phone 8.1, pero supone un cambio respecto a Windows 8.1, que usaba controles [ComboBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.combobox). El uso de los controles flotantes permite crear selectores de hora y fecha personalizados con facilidad.
Nuevas API de ScrollViewer | [ScrollViewer](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer) tiene los nuevos eventos [DirectManipulationStarted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationstarted) y [DirectManipulationCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.scrollviewer.directmanipulationcompleted), para notificar a la aplicación cuándo se inicia y se detiene el movimiento panorámico táctil. Puedes controlar estos eventos para coordinar tu interfaz de usuario con estas acciones de usuario.
Actualizaciones de MenuFlyout | En las aplicaciones universales de Windows, hay nuevas API que te permiten compilar mejores menús contextuales con mayor facilidad. El nuevo método [MenuFlyout.ShowAt](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.menuflyout.showat) te permite especificar dónde quieres que aparezca el control flotante en relación con otro elemento. (Y el MenuFlyout incluso se puede superponer a los límites de la ventana de tu aplicación). Usa la nueva clase [MenuFlyoutSubItem](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.menuflyoutsubitem) para crear menús en cascada.
Nuevas propiedades de borde para ContentPresenter, Grid y StackPanel | Los controles de contenedor comunes tienen nuevas propiedades de borde que te permiten dibujar un borde alrededor de ellos sin agregar un elemento de borde adicional en el XAML. [ContentPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentpresenter), [Grid](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.grid) y [StackPanel](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.stackpanel) tienen estas nuevas propiedades: BorderBrush, BorderThickness, CornerRadius y Padding.
Nuevas API de texto en ContentPresenter | [ContentPresenter](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentpresenter) tiene API nuevas que ofrecen un mayor control sobre la presentación del texto: LineHeight, LineStackingStrategy, MaxLines y TextWrapping.
Elementos visuales de foco del sistema | Ahora el sistema crea elementos visuales de foco para controles XAML, en lugar de declararse como elementos XAML en la plantilla de control. Por lo general, los elementos visuales de foco no suelen ser necesarios en los dispositivos móviles, y se mejora el rendimiento de la aplicación al permitir que el sistema los cree y administre según sea necesario. Si necesita un mayor control sobre los elementos visuales de foco, puedes invalidar el comportamiento del sistema y ofrecer una plantilla de control personalizado que defina los elementos visuales de foco. Consulta [UseSystemFocusVisuals](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.usesystemfocusvisuals) e [IsTemplateFocusTarget](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.istemplatefocustargetproperty) para obtener más información.
PasswordBox.PasswordRevealMode | En las aplicaciones universales de Windows, la propiedad [PasswordRevealMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.passwordbox.passwordrevealmode) reemplaza la propiedad IsPasswordRevealButtonEnabled para ofrecer un comportamiento coherente en todas las familias de dispositivos. **Precaución:** Antes de Windows 10, el botón para mostrar la contraseña no se mostraba de manera predeterminada; en cambio, en las aplicaciones universales de Windows se muestra de forma predeterminada. Si la seguridad de la aplicación requiere que la contraseña esté siempre oculta, asegúrate de establecer el valor de PasswordRevealMode en Oculta.
Control.IsTextScaleFactorEnabled | La propiedad [IsTextScaleFactorEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.control.istextscalefactorenabledproperty) que estaba disponible en Windows Phone 8.1 está ahora disponible para aplicaciones universales de Windows en todas las familias de dispositivos.
AutoSuggestBox | El control [AutoSuggestBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox) de Windows Phone 8.1 ahora está disponible para aplicaciones universales de Windows en todas las familias de dispositivos y debes usarlo en lugar de [SearchBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.searchbox). AutoSuggestBox proporciona sugerencias mientras el usuario escribe, y funciona bien con diversos tipos de entrada, como la entrada táctil, el teclado y los Editores de métodos de entrada. También tiene algunos miembros nuevos para que funcione mejor como un cuadro de búsqueda: la propiedad [QueryIcon](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox.queryicon) y el evento [QuerySubmitted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.autosuggestbox.querysubmitted).
ContentDialog | El control [ContentDialog](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.contentdialog) de Windows Phone 8.1 ahora está disponible para aplicaciones universales de Windows en todas las familias de dispositivos. ContentDialog permite mostrar un cuadro de diálogo modal personalizable que funciona perfectamente en toda la gama de dispositivos.
Pivot | El control [Pivot](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.pivot) de Windows Phone 8.1 ahora está disponible para aplicaciones universales de Windows en todas las familias de dispositivos. Ahora puedes usar el mismo control Pivot en tu aplicación para dispositivos móviles y de escritorio. Pivot ofrece un comportamiento adaptativo en función del tamaño de la pantalla y el tipo de entrada. Puedes aplicar estilo a un control Pivot para ofrecer un comportamiento similar al de las pestañas, con diferentes vistas de información en cada elemento dinámico.

## <a name="text"></a>Text

Característica | Descripción
 :---- | :----
API de texto principales de Windows | El nuevo espacio de nombres [Windows.UI.Text.Core](https://docs.microsoft.com/uwp/api/windows.ui.text.core) ofrece un sistema de cliente/servidor que centraliza el procesamiento de entrada de teclado en un solo servidor. Puedes usarlo para manipular el búfer de edición del control de entrada de texto personalizado. El servidor de entrada de texto se asegura de que el contenido del control de entrada de texto y el contenido de su búfer de edición estén siempre sincronizados a través de un canal de comunicación asincrónica entre la aplicación y el servidor.
Iconos de vector | El elemento [Glyphs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs) tiene las nuevas propiedades [IsColorFontEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs.iscolorfontenabled) y [ColorFontPalleteIndex](https://docs.microsoft.com/uwp/api/windows.ui.xaml.documents.glyphs.colorfontpaletteindex) para admitir fuentes de colores; ahora puedes usar un archivo de fuente para representar iconos basados en fuentes. Cuando usas ColorFontPalleteIndex para cambiar la paleta de colores, se puede representar un solo icono con conjuntos de colores diferentes; por ejemplo, para mostrar una versión habilitada y deshabilitada del icono.
Eventos de ventana del Editor de métodos de entrada | A veces, los usuarios escriben texto mediante un Editor de métodos de entrada que se muestra en una ventana justo debajo de un cuadro de entrada de texto (normalmente para idiomas de Asia Oriental). Puedes usar el evento CandidateWindowBoundsChanged y la propiedad DesiredCandidateWindowAlignment en [TextBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textbox) y [RichEditBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.richeditbox) para que la interfaz de usuario de la aplicación funcione mejor con la ventana del IME.
Eventos de composición de texto | [TextBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.textbox) y [RichEditBox](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.richeditbox) tienen nuevos eventos para informar a la aplicación de cuándo se crea el texto mediante un Editor de métodos de entrada: TextCompositionStarted, TextCompositionEnded y TextCompositionChanged. Puedes controlar estos eventos para coordinar el código de la aplicación con el proceso de composición del texto del IME. Por ejemplo, podrías implementar la funcionalidad de finalización automática en línea para idiomas de Asia oriental.
Control mejorado del texto bidireccional | Los controles de texto XAML tienen una nueva API para mejorar el control del texto bidireccional, lo que da lugar a una mejor direccionalidad de párrafo y alineación de texto en una variedad de idiomas de entrada. El valor predeterminado de la propiedad TextReadingOrder se ha cambiado a DetectFromContent, por lo que la compatibilidad para detectar el orden de lectura está habilitada de manera predeterminada. También se ha agregado la propiedad TextReadingOrder a PasswordBox, RichEditBox y TextBox. Puede establecer la propiedad TextAlignment en controles de texto en el nuevo valor de DetectFromContent para optar por recibir tener la alineación detectada automáticamente desde el contenido.
Representación de texto | En Windows 10, el texto en aplicaciones XAML representa ahora, en la mayoría de las situaciones, a casi dos veces la velocidad de Windows 8.1. En la mayoría de los casos, las aplicaciones se beneficiarán de esta mejora sin necesidad de cambios. Además de una representación más rápida, estas mejoras también reducen el consumo de memoria típico de las aplicaciones XAML en un 5 %.

## <a name="application-model"></a>Modelo de aplicación

Característica | Descripción
 :---- | :----
Cortana | Amplía la funcionalidad básica de Cortana con comandos de voz que inicien y ejecuten una acción única en una aplicación externa. Al integrar la funcionalidad básica de tu aplicación y ofrecer un punto de entrada central para que el usuario realice la mayoría de las tareas sin tener que abrir la aplicación directamente, Cortana puede ser un enlace entre tu aplicación y el usuario. En muchos casos, esto puede ahorrarle al usuario un tiempo y esfuerzo considerables. Aprende cómo [integrar tu aplicación en el lienzo de Cortana](https://docs.microsoft.com/previous-versions/windows/apps/dn974230(v=win.10)). Si necesitas ideas, puede consultar las recomendaciones de diseño y las directrices de experiencia del usuario específicas para Cortana en [Conceptos básicos de diseño de aplicaciones universales de Windows](https://developer.microsoft.com/windows/design/layout).
Explorador de archivos | Los nuevos métodos [Windows.System.Launcher.LaunchFolderAsync](https://docs.microsoft.com/uwp/api/windows.system.launcher.launchfolderasync) permiten iniciar el Explorador de archivos y muestran el contenido de una carpeta que especifiques.
Almacenamiento compartido | La nueva clase [Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager](https://docs.microsoft.com/uwp/api/windows.applicationmodel.datatransfer.sharedstorageaccessmanager) y sus métodos te permiten compartir un archivo con otra aplicación al pasar un token de uso compartido cuando inicias la otra aplicación mediante la activación de URI. La aplicación de destino canjea el token para conseguir el archivo compartido por la aplicación de origen.
Configuración | Muestra las páginas de configuración integradas al usar el protocolo ms-settings con el método [LaunchUriAsync](https://docs.microsoft.com/uwp/api/windows.system.launcher.launchuriasync). Por ejemplo, el siguiente código muestra la página de configuración de Wi-Fi: **bool result = await Launcher.LaunchUriAsync(new Uri("ms-settings://network/wifi"));** <br /><br />Para obtener una lista de las páginas de configuración que puedes mostrar, consulta [Cómo mostrar páginas de configuración integradas con el protocolo ms-ajustes](https://docs.microsoft.com/previous-versions/windows/apps/jj207014(v=vs.105)).
Comunicación de una aplicación a otra | Las nuevas API de [comunicación de una aplicación a otra](https://docs.microsoft.com/previous-versions/windows/apps/dn997827(v=win.10)) en Windows 10 permiten que las aplicaciones Windows (así como las aplicaciones web de Windows) se inicien entre sí e intercambien archivos y datos. Con estas nuevas API, las tareas complejas que hubieran requerido que el usuario usara varias aplicaciones se pueden controlar ahora sin problemas. Por ejemplo, la aplicación podría iniciar una aplicación de redes sociales para elegir un contacto o iniciar una aplicación de confirmación de compra para completar un proceso de pago.
Servicios de aplicaciones | Un servicio de aplicaciones es un modo de que una aplicación proporcione servicios a otras aplicaciones en Windows 10. Un servicio de aplicaciones tiene la forma de una tarea en segundo plano. Las aplicaciones en primer plano pueden llamar a un servicio de aplicación en otra aplicación para realizar tareas en segundo plano. Para obtener información de referencia acerca de la API del servicio de aplicación, consulta [Windows.ApplicationModel.AppService](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.AppService).
Manifiesto del paquete de la aplicación | Las actualizaciones de la referencia del [esquema de manifiesto del paquete](https://docs.microsoft.com/uwp/schemas/appxpackage/appx-package-manifest) para Windows 10 incluyen elementos que se han agregado, quitado y cambiado. Consulta [Jerarquía de elementos](https://docs.microsoft.com/uwp/schemas/appxpackage/uapmanifestschema/root-elements) para obtener información de referencia sobre todos los elementos, atributos y tipos del esquema.

## <a name="devices"></a>Dispositivos

Característica | Descripción
 :---- | :----
Microsoft Surface Hub | Microsoft Surface Hub es un dispositivo de colaboración de equipos eficaz y una plataforma de pantalla grande para las aplicaciones universales de Windows que se ejecutan de forma nativa desde Surface Hub o desde el dispositivo conectado. Crea tus propias aplicaciones, diseñadas específicamente para tu negocio, que aprovechen las ventajas de la pantalla grande, la entrada táctil y manuscrita, y una gran cantidad de hardware incorporado como cámaras y sensores.<br /><br />Echa un vistazo a las recomendaciones de diseño y las directrices de experiencia del usuario específicas de Surface Hub en [Conceptos básicos de diseño de aplicaciones universales de Windows](https://developer.microsoft.com/windows/design/layout). Estos documentos explican técnicas de diseño con capacidad de respuesta para aplicaciones universales de Windows. <br /><br />Para obtener más detalles sobre cómo admitir aplicaciones compartidas comunes, consulta [SharedModeSettings](https://docs.microsoft.com/uwp/api/windows.system.profile.sharedmodesettings). Para obtener información sobre la entrada manuscrita y detalles sobre la compatibilidad con la entrada manuscrita de varios puntos en el nuevo control [InkCanvas](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.inkcanvas), consulta [Windows.UI.Input.Inking](https://docs.microsoft.com/uwp/api/windows.ui.input.inking) y [Windows.UI.Input.Inking.Core](https://docs.microsoft.com/uwp/api/windows.ui.input.inking.core). Para controlar la entrada del sensor, consulta [Integración de dispositivos, impresoras y sensores](https://docs.microsoft.com/previous-versions/windows/apps/br229563(v=win.10)).
Ubicación | Windows 10 incorpora un nuevo método de solicitud de permiso al usuario para obtener acceso a su ubicación, [RequestAccessAsync](https://docs.microsoft.com/uwp/api/windows.devices.geolocation.geolocator.requestaccessasync). El usuario establece la privacidad de sus datos de ubicación con la **configuración de privacidad de ubicación** en la aplicación **Configuración**. La aplicación puede acceder a la ubicación del usuario solo cuando: **Ubicación para este dispositivo** está activado *(no se aplica para Windows 10 para teléfonos)* , la configuración de los servicios de ubicación "**Ubicación**" está activada y, en **Elige las aplicaciones que pueden usar tu ubicación**, tu aplicación está activada. <br /><br />Es importante llamar a **RequestAccessAsync** antes de acceder a la ubicación del usuario. En ese momento, la aplicación debe estar en primer plano y se debe llamar a **RequestAccessAsync** desde el subproceso de la interfaz de usuario. La aplicación no puede tener acceso a los datos de ubicación hasta que el usuario conceda permiso.
AllJoyn | El espacio de nombres [Windows.Devices.AllJoyn](https://docs.microsoft.com/uwp/api/windows.devices.alljoyn) de Windows Runtime incorpora la implementación de los servicios y el marco de software de código abierto de AllJoyn de Microsoft. Estas API permiten que tu aplicación universal para dispositivos Windows participe con otros dispositivos de escenarios de Internet de las cosas (IoT) controlados por AllJoyn. Para obtener más detalles sobre las API C de AllJoyn, descarga la documentación en [The AllSeen Alliance](https://allseenalliance.org/). Usa la herramienta [AllJoynCodeGen](https://docs.microsoft.com/previous-versions/windows/apps/dn913809(v=win.10)) que se incluye en este lanzamiento para generar un componente de Windows que puedas usar para habilitar escenarios de AllJoyn en tu aplicación de dispositivo. <br /><br />**Nota:** Windows 10 IoT Core ahora está disponible para una nueva clase de dispositivos pequeños, lo que te permite crear dispositivos de "Internet de las cosas" (IoT) con Windows y Visual Studio. Averigua más sobre [Windows IoT en el Centro de desarrollo de Windows](https://developer.microsoft.com/windows/iot).
API de impresión en móviles (XAML) | Hay un conjunto único y unificado de API que te permite imprimir desde tus aplicaciones para UWP basadas en XAML entre las familias de dispositivos, incluidos los dispositivos móviles. Ahora puedes agregar impresión a tu aplicación móvil mediante las API típicas relacionadas con la impresión desde los espacios de nombres Windows.Graphics.Printing y Windows.UI.Xaml.Printing.
Batería | Con las API de batería del espacio de nombres [Windows.Devices.Power](https://docs.microsoft.com/uwp/api/windows.devices.power), tu aplicación puede obtener más información sobre las baterías que están conectadas al dispositivo que ejecuta la aplicación. Crea un objeto [Battery](https://docs.microsoft.com/uwp/api/windows.devices.power.battery) para representar un controlador individual de la batería o a un agregado de todos los controladores de la batería (cuando lo cree [FromIdAsync](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.fromidasync) o [AggregateBattery](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.aggregatebattery), respectivamente). Usa el método [GetReport](https://docs.microsoft.com/uwp/api/windows.devices.power.battery.getreport) para devolver un objeto [BatteryReport](https://docs.microsoft.com/uwp/api/windows.devices.power.batteryreport) que indique la carga, la capacidad y el estado de las baterías correspondientes.
Dispositivos MIDI | El nuevo espacio de nombres [Windows.Devices.Midi](https://docs.microsoft.com/uwp/api/windows.devices.midi) te permite crear aplicaciones que se pueden comunicar con dispositivos MIDI externos, aplicaciones y dispositivos externos que se comunican directamente con el sintetizador de software de Microsoft GS MIDI y escenarios donde varios clientes acceden al mismo a un solo puerto MIDI.
Compatibilidad del sensor personalizado | El espacio de nombres [Windows.Devices.Sensors.Custom](https://docs.microsoft.com/uwp/api/windows.devices.sensors.custom) permite a los desarrolladores de hardware definir nuevos tipos de sensores personalizados, como un sensor de CO2.
Emulación de tarjeta basada en host (HCE) | La emulación de tarjeta de host te permite implementar servicios de emulación de tarjeta NFC hospedados en el sistema operativo y aun así poder comunicarte con el terminal del lector externo mediante la radio NFC. Para desencadenar una tarea en segundo plano para emular una tarjeta inteligente a través de NFC, usa la clase [SmartCardTrigger](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.Background.SmartCardTrigger). El valor EmulatorHostApplicationActivated de la enumeración [SmartCardTriggerType](https://docs.microsoft.com/uwp/api/Windows.Devices.SmartCards.SmartCardTriggerType) permite que la aplicación sepa si se produjo un evento HCE.

## <a name="graphics"></a>Gráficos

Característica | Descripción
 :---- | :----
DirectX | DirectX 12 en Windows 10 incorpora la nueva versión de Microsoft Direct3D, la API de gráficos 3D en el corazón de DirectX. [Direct3D 12 Graphics](https://msdn.microsoft.com/library/windows/desktop/dn903821(v=vs.85).aspx) ofrece la eficacia y el rendimiento de una API de tipo consola de bajo nivel. Direct3D 12 es más rápido y más eficiente que nunca. Permite crear escenas más vivaces, más objetos, efectos más complejos, así como mejorar el uso del hardware gráfico moderno.
SoftwareBitmapSource | En las aplicaciones universales de Windows, puedes usar el nuevo tipo [SoftwareBitmapSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.imaging.softwarebitmapsource) como origen de imagen XAML. Esto te permite pasar imágenes sin codificación al marco XAML para que se muestren inmediatamente en pantalla, omitiendo la descodificación de imágenes por el marco XAML. Puedes lograr una representación de imágenes mucho más rápida, como la representación de fotos de retardo bajo directamente desde la cámara, usando descodificadores de imagen personalizados, capturando fotogramas desde superficies de DirectX, o incluso creando imágenes en memoria desde cero y representándolas todas directamente en XAML con latencia baja y baja sobrecarga de memoria.
Cámara perspectiva | En aplicaciones universales de Windows, XAML tiene una nueva API de Transform3D que permite aplicar transformaciones de perspectiva a un árbol XAML (o escena), que transforma todos los elementos secundarios XAML en función de esa transformación única de toda la escena (o cámara). Podrías hacer esto anteriormente con MatrixTransform y matemáticas complejas, pero Transform3D simplifica en gran medida este efecto y también permite la animación del efecto. Para obtener más información, consulta la propiedad [UIElement.Transform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.transform3d), [Transform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.transform3d), [CompositeTransform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.compositetransform3d) y [PerspectiveTransform3D](https://docs.microsoft.com/uwp/api/windows.ui.xaml.media.media3d.perspectivetransform3d).

## <a name="media"></a>Multimedia

Característica | Descripción
 :---- | :----
HTTP Live Streaming | Puedes usar la nueva clase [AdaptiveMediaSource](https://docs.microsoft.com/uwp/api/windows.media.streaming.adaptive.adaptivemediasource) para agregar capacidades de streaming de vídeo adaptable a las aplicaciones. Para inicializar el objeto, debes apuntarlo a un archivo de manifiesto de streaming. Los formatos de manifiesto compatibles incluyen Http Live Streaming (HLS) y Dynamic Adaptive Streaming over HTTP (DASH). Una vez el objeto está enlazado a un elemento multimedia XAML, se inicia la reproducción adaptable. Las propiedades del flujo como, por ejemplo, la velocidad de bits disponible, mínima y máxima, se pueden consultar y establecer según sea necesario.
Compatibilidad del procesador Transcode Video Processor (XVP) de Media Foundation con las Transformaciones de Media Foundation (MFT) | Las aplicaciones de Windows que usan Transformaciones de Media Foundation (MFT) ahora pueden usar el procesador **Transcode Video Processor (XVP) de Media Foundation** para convertir, escalar y transformar datos de vídeo sin procesar: El nuevo atributo [MF_XVP_CALLER_ALLOCATES_OUTPUT](https://docs.microsoft.com/windows/desktop/medfound/mf-xvp-caller-allocates-output) permite la salida a texturas asignadas por el llamador incluso en el modo Microsoft DirectX Video Acceleration (DXVA) La nueva interfaz [IMFVideoProcessorControl2](https://docs.microsoft.com/windows/desktop/api/mfidl/nn-mfidl-imfvideoprocessorcontrol2) permite a la aplicación habilitar efectos de hardware, consultar efectos de hardware admitidos y omitir la operación de rotación realizada por el procesador de vídeo.
Transcodificación | La nueva API [MediaProcessingTrigger](https://docs.microsoft.com/uwp/api/Windows.ApplicationModel.Background.MediaProcessingTrigger) permite que la aplicación haga la transcodificación multimedia en una tarea en segundo plano, para que las operaciones de transcodificación continúen incluso cuando la aplicación en primer plano haya terminado.
Eventos de error de medios de MediaElement | En las aplicaciones universales de Windows, [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) reproducirá el contenido que abarque varios flujos, incluso si hay un error en la descodificación de uno de los flujos, siempre y cuando el contenido multimedia incluya al menos un flujo válido. Por ejemplo, si se produce un error en la secuencia de vídeo en un contenido con secuencia de vídeo y audio, [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) seguirá reproduciendo la secuencia de audio. [PartialMediaFailureDetected](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.partialmediafailuredetected) notifica que una de las secuencias dentro de una secuencia no se puede descodificar. También permite saber qué tipo de secuencia dio error para poder reflejar esa información en la interfaz de usuario. Si todos los flujos de un flujo multimedia dan error, se genera el evento [MediaFailed](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.mediafailed).
Compatibilidad con la emisión de vídeo adaptativa con MediaElement | [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) tiene el nuevo método [SetPlaybackSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.setplaybacksource) para admitir el streaming de vídeo adaptable. Usa este método para establecer el origen multimedia en un AdaptiveMediaSource.
Conversión con MediaElement e Image | Los controles [MediaElement](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.MediaElement) e Image tienen el nuevo método [GetAsCastingSource](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.getascastingsource). Puedes usar este método para enviar contenido mediante programación desde cualquier elemento de imagen o multimedia a una gama más amplia de dispositivos remotos, como Miracast, Bluetooth y DLNA. Esta funcionalidad se habilita automáticamente cuando estableces [AreTransportControlsEnabled](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaelement.aretransportcontrolsenabled) en true en un MediaElement.
Controles de transporte multimedia para aplicaciones de escritorio | La interfaz de [ISystemMediaTransportControls](https://msdn.microsoft.com/library/windows/desktop/dn892299(v=vs.85).aspx) y las API relacionadas permiten que las aplicaciones de escritorio interactúen con los controles de transporte multimedia del sistema integrados. Esto incluye responder a las interacciones del usuario con los botones de los controles de transporte y actualizar la visualización de los controles de transporte para mostrar metadatos sobre el contenido multimedia que se está reproduciendo actualmente.
Codificación y descodificación de JPEG de acceso aleatorio | Los nuevos métodos WIC [IWICJpegFrameEncode](https://msdn.microsoft.com/library/windows/desktop/dn903864(v=vs.85).aspx) y [IWICJpegFrameDecode](https://msdn.microsoft.com/library/windows/desktop/dn903834(v=vs.85).aspx) habilitan la codificación y descodificación de imágenes JPEG. Ahora también puedes habilitar la indización de los datos de imagen, que proporciona acceso aleatorio eficaz para imágenes grandes a costa de una superficie de memoria mayor.
Superposiciones para composiciones multimedia | Las nuevas API [MediaOverlay](https://docs.microsoft.com/uwp/api/Windows.Media.Editing.MediaOverlay) y [MediaOverlayLayer](https://docs.microsoft.com/uwp/api/Windows.Media.Editing.MediaOverlayLayer) facilitan agregar varias capas de contenido multimedia estático o dinámico a una composición multimedia. Se puede ajustar la opacidad, la posición y el tiempo para cada capa e incluso puede implementar su propio compositor personalizado para las capas de entrada.
Nuevo marco de efectos | El espacio de nombres [Windows.Media.Effects](https://docs.microsoft.com/uwp/api/windows.media.effects) proporciona un marco sencillo e intuitivo para agregar efectos a secuencias de audio y vídeo. El marco incluye interfaces básicas que se pueden implementar para crear efectos de vídeo y audio personalizados e insertarlos en la canalización multimedia.

## <a name="networking"></a>Funciones de red

Característica | Descripción
 :---- | :----
Sockets | Entre las actualizaciones de sockets se incluyen: <br /><br />**Agente de socket:** El agente de socket puede establecer y cerrar las conexiones de socket en nombre de una aplicación en cualquier estado del ciclo de vida de la aplicación. Esto permite detectar más fácilmente las aplicaciones y los servicios estas que proporcionan. Por ejemplo, mediante el agente de socket, un servicio de Win32 puede aceptar conexiones entrantes de socket aunque no se esté ejecutando. <br /><br />**Mejoras de rendimiento:** El rendimiento de socket se ha optimizado para las aplicaciones que usan el espacio de nombres Windows.Networking.Sockets.
Tareas de posprocesamiento de la transferencia en segundo plano | Las nuevas API del espacio de nombres [Windows.Networking.BackgroundTransfer](https://docs.microsoft.com/uwp/api/windows.networking.backgroundtransfer) permiten registrar grupos de tareas de posprocesamiento. Por lo tanto, la aplicación puede actuar inmediatamente tanto si las transferencias en segundo plano se realizan de forma correcta o incorrecta y aunque no esté en primer plano, en lugar de esperar a que el usuario reanude la aplicación la próxima vez.
Compatibilidad con Bluetooth para los anuncios | Con el espacio de nombres [Windows.Devices.Bluetooth.Advertisement](https://docs.microsoft.com/uwp/api/windows.devices.bluetooth.advertisement), las aplicaciones pueden enviar, recibir y filtrar anuncios de Bluetooth LE.
Actualización de la API de Wi-Fi Direct | El agente del dispositivo se actualiza para permitir el emparejamiento con dispositivos sin tener que dejar la aplicación. Las adiciones al espacio de nombres [Windows.Devices.WiFiDirect](https://docs.microsoft.com/uwp/api/windows.devices.wifidirect) también permiten que otros dispositivos puedan detectar un dispositivo y que este escuche las notificaciones de conexión entrante.<br /><br />**Nota:** En esta versión, las mejoras de la función Wi-Fi Direct no se integran en la experiencia del usuario y solo admiten el emparejamiento con el botón de comando. Asimismo, esta versión solo admite una conexión activa.
Mejoras de compatibilidad con JSON | El espacio de nombres [Windows.Data.Json](https://docs.microsoft.com/uwp/api/windows.data.json) ahora ofrece mayor compatibilidad con las definiciones estándar existentes y la experiencia del desarrollador al convertir los objetos JSON durante las sesiones de depuración.

## <a name="security"></a>Seguridad

Característica | Descripción
 :---- | :----
Cifrado ECC | Las nuevas API del espacio de nombres [Windows.Security.Cryptography](https://docs.microsoft.com/uwp/api/windows.security.cryptography) ofrecen compatibilidad con la criptografía de curva elíptica (ECC), una implementación de criptografía de clave pública basada en curvas elípticas sobre campos finitos. ECC es matemáticamente más complejo que RSA, proporciona tamaños más pequeños de claves, reduce el consumo de la memoria y mejora el rendimiento. Esto ofrece una alternativa a las claves de RSA y a los parámetros de la curva aprobados por NIST para los servicios y los clientes de Microsoft.
Microsoft Passport | Microsoft Passport es un método alternativo de autenticación que reemplaza las contraseñas con criptografía asimétrica y un gesto. Las clases del espacio de nombres de credenciales, como [KeyCredentialManger](https://docs.microsoft.com/uwp/api/windows.security.credentials.keycredentialmanager), facilitan a los desarrolladores la creación de aplicaciones con Microsoft Passport sin la complejidad de la criptografía o la biométrica.
Microsoft Passport para el trabajo | Microsoft Passport para el trabajo es un método alternativo para iniciar sesión en Windows con tu cuenta de Azure Active Directory que no use contraseñas, tarjetas inteligentes y tarjetas inteligentes virtuales. Puede optar por deshabilitar o habilitar esta configuración de directiva.
Agente de token | El Agente de token es un nuevo marco de autenticación que facilita que las aplicaciones se conecten a los proveedores de identidad en línea (como Facebook). Características como la administración de nombres de usuario y contraseñas de cuenta y una interfaz de usuario optimizada proporcionan una experiencia de autenticación mejorada para los usuarios.

## <a name="system-services"></a>Servicios del sistema

Característica | Descripción
 :---- | :----
Alimentación | La aplicación de escritorio de Windows ahora puede recibir notificaciones cuando se active o desactive el ahorro de batería. Al responder a cambios en las condiciones de energía, la aplicación tiene la oportunidad de ayudar a prolongar la duración de la batería. <br /><br />[GUID_POWER_SAVING_STATUS](https://docs.microsoft.com/windows/desktop/Power/power-setting-guids): Usa este nuevo GUID con la función [PowerSettingRegisterNotification](https://msdn.microsoft.com/library/windows/desktop/hh769082(v=vs.85).aspx) para recibir notificaciones cuando el ahorro de batería se active o desactive. <br /><br />[SYSTEM_POWER_STATUS](https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-_system_power_status): Esta estructura se ha actualizado para admitir el ahorro de batería. El cuarto miembro, *SystemStatusFlag* (denominado anteriormente Reserved1), indica si el ahorro de batería está activado o no. Usa la función [GetSystemPowerStatus](https://msdn.microsoft.com/library/windows/desktop/aa372693(v=vs.85).aspx) para recuperar un puntero a esta estructura.
Versión | Puedes usar las [funciones de la aplicación auxiliar de versiones](https://docs.microsoft.com/windows/desktop/SysInfo/version-helper-apis) para determinar la versión del sistema operativo. Para Windows 10, estas funciones de la aplicación auxiliar incluyen una función nueva, [IsWindows10OrGreater](https://msdn.microsoft.com/library/windows/desktop/dn905474(v=vs.85).aspx). Debes usar las funciones de la aplicación auxiliar en lugar de las funciones [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) y [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) desusadas cuando quieras determinar la versión del sistema. Para obtener más información acerca de cómo obtener la versión del sistema, consulta [Obtener la versión del sistema](https://docs.microsoft.com/windows/desktop/SysInfo/getting-the-system-version). <br /><br />Si usas las funciones [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) o [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion) en desuso para obtener información sobre la versión en una estructura [OSVERSIONINFOEX](https://msdn.microsoft.com/library/windows/desktop/ms724833(v=vs.85).aspx) u [OSVERSIONINFO](https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_osversioninfoa), ten en cuenta que el número de versión que contienen estas estructuras aumenta de 6.3 para Windows 8.1 y Windows Server 2012 R2 a 10.0 para Windows 10. Para obtener más información sobre los números de versión del sistema operativo, consulta [Versión del sistema operativo](https://docs.microsoft.com/windows/desktop/SysInfo/operating-system-version). <br /><br />También tienes que tener como destino específico Windows 8.1 o Windows 10 en la aplicación para obtener la información de la versión correcta de estas versiones con la función [GetVersionEx](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversionexa) o [GetVersion](https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getversion). Para obtener información acerca de cómo seleccionar tu aplicación como destino para estas versiones de Windows, consulta [Tener tu aplicación como destino para Windows](https://docs.microsoft.com/windows/desktop/SysInfo/targeting-your-application-at-windows-8-1).
Información de usuario | Las nuevas API del espacio de nombres de [Windows.System](https://docs.microsoft.com/uwp/api/windows.system) facilitan el acceso a la información sobre un usuario, como su nombre de usuario e imagen de cuenta. También proporciona la capacidad de responder a eventos de usuario, como el inicio y el cierre de sesión.
Administración de memoria y creación de perfiles | La compatibilidad con la API de generación de perfiles de memoria de [Windows.System](https://docs.microsoft.com/uwp/api/windows.system) se ha ampliado a todas las plataformas y su funcionalidad general se ha mejorado con nuevas clases y funciones.

## <a name="storage"></a>Almacenamiento

Característica | Descripción
 :---- | :----
API de búsqueda de archivos para Windows Phone | Como editor de aplicaciones, para registrar la aplicación con el fin de que comparta una carpeta del almacenamiento con otras aplicaciones que publiques puedes agregar extensiones al manifiesto de la aplicación. A continuación, llama el método [Windows.Storage.ApplicationData.GetPublisherCacheFolder](https://docs.microsoft.com/uwp/api/windows.storage.applicationdata.getpublishercachefolder) para obtener la ubicación del almacenamiento compartido. El modelo de seguridad sólida de las aplicaciones de Windows Runtime evita que las aplicaciones compartan datos entre ellas. No obstante, esto puede resultar útil para que las aplicaciones del mismo editor compartan archivos y valores de configuración de forma individual para cada usuario.

## <a name="tools"></a>Herramientas

Característica | Descripción
 :---- | :----
Árbol visual dinámico en Visual Studio | Visual Studio tiene una nueva función de árbol visual dinámico. Puedes usarla durante la depuración para comprender con rapidez el estado del árbol visual de la aplicación y descubrir cómo se establecieron las propiedades del elemento. También te permite cambiar los valores de propiedad mientras se ejecuta la aplicación, para que puedas retocar y experimentar sin tener que reiniciar.
Registro de seguimiento | [TraceLogging](https://msdn.microsoft.com/library/windows/desktop/dn904636(v=vs.85).aspx) es una nueva API de seguimiento de eventos de las aplicaciones de modo usuario y los controladores de modo kernel; se basa en el [Seguimiento de eventos para Windows](https://msdn.microsoft.com/library/windows/desktop/bb968803(v=vs.85).aspx) (ETW). Esta API ofrece una manera simplificada de instrumentar código e incluir datos estructurados con eventos sin necesitar un archivo XML de manifiesto de instrumentación independiente. Las API TraceLogging de WinRT, .NET y C/C++ están disponibles para los distintos tipos de desarrolladores.

## <a name="user-experience"></a>Experiencia del usuario

Característica | Descripción
 :---- | :----
Reconocimiento de voz | El reconocimiento de voz continuo para escenarios de dictado de formato largo ahora es compatible con la Plataforma universal de Windows. Consulta cómo habilitar el dictado continuo en los Documentos de interacción de voz.
Capacidades de arrastrar y colocar entre distintas plataformas de aplicaciones | Los nuevos espacios de nombres [Windows.ApplicationModel.DataTransfer.DragDrop](https://docs.microsoft.com/uwp/api/windows.applicationmodel.datatransfer.dragdrop) incorporan la función de arrastrar y colocar en las aplicaciones universales de Windows. Los escenarios comunes de arrastrar y colocar que anteriormente se permitían en los programas de escritorio (por ejemplo, arrastrar un documento de una carpeta a un mensaje de correo de Outlook para adjuntarlo) no son posibles con las aplicaciones universales de Windows. Con estas nuevas API, la aplicación puede permitir que los usuarios muevan datos fácilmente entre diferentes aplicaciones universales de Windows y el escritorio. <br /><br />Para admitir la acción de arrastrar y colocar entre aplicaciones, se han agregado las siguientes API nuevas a XAML: [ListViewBase.DragItemsCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.listviewbase.dragitemscompleted); <br />UIElement: [CanDrag](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.candrag), [DragStarting](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dragstarting), [StartDragAsync](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.startdragasync), [DropCompleted](https://docs.microsoft.com/uwp/api/windows.ui.xaml.uielement.dropcompleted);  <br />[DragOperationDeferral](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragoperationdeferral), [DragUI](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragui), [DragUIOverride](https://docs.microsoft.com/uwp/api/windows.ui.xaml.draguioverride); <br />DragEventArgs: [AcceptedOperation](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.acceptedoperation), [DataView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.dataview), [DragUIOverride](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.draguioverride), [GetDeferral](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.getdeferral), [Modifiers](https://docs.microsoft.com/uwp/api/windows.ui.xaml.drageventargs.modifiers); <br />[DragItemsCompletedEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.dragitemscompletedeventargs), [DropCompletedEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dropcompletedeventargs), [DragStartingEventArgs](https://docs.microsoft.com/uwp/api/windows.ui.xaml.dragstartingeventargs)
Barras de título de ventanas personalizadas | Para las aplicaciones para UWP de la familia de dispositivos de escritorio, ahora puedes usar la clase [ApplicationViewTitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationviewtitlebar) con la propiedad [ApplicationView.TitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) y el método [Window.SetTitleBar](https://docs.microsoft.com/uwp/api/windows.ui.viewmanagement.applicationview.titlebar) para reemplazar el contenido de la barra de título de Windows predeterminado por su propio contenido XAML personalizado. El código XAML se trata como "cromo del sistema", por lo que Windows administrará los eventos de entrada en lugar de la aplicación. Esto significa que el usuario puede seguir arrastrando y cambiando el tamaño de la ventana, incluso al hacer clic en el contenido de la barra de título personalizado.

## <a name="web"></a>Web

Característica | Descripción
 :---- | :----
Microsoft Edge | Microsoft Edge es el nuevo explorador predeterminado creado para Windows 10. Para obtener más información y una visión general de las características de desarrollo y los estándares incluidos en Microsoft Edge, incluidas las últimas características de JavaScript, consulta la [Guía para desarrolladores de Microsoft Edge](https://developer.microsoft.com/microsoft-edge/platform/documentation/dev-guide/).
Exploración de WebView | El control [WebView](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview) usa el mismo motor de representación que el nuevo explorador Microsoft Edge. Esto ofrece el modo más preciso y conforme a los estándares de la representación HTML.
WebView fuera de subproceso | Puedes especificar un [WebView.ExecutionMode](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.executionmode) para permitir el procesamiento y la visualización de contenido web en un subproceso en segundo plano independiente. Esto puede mejorar el rendimiento en determinados escenarios específicos.
Evento WebView.UnsupportedUriSchemeIdentified | El nuevo evento [WebView.UnsupportedUriSchemeIdentified](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.unsupportedurischemeidentified) te permite decidir la manera en que tu aplicación debería tratar un esquema URI no admitido. Puedes controlar este evento para que la aplicación ofrezca la administración personalizada de los esquemas URI no admitidos. Para el control WebView HTML, consulta el evento [MSWebViewUnsupportedUriSchemeIdentified](https://docs.microsoft.com/previous-versions/windows/apps/dn803906(v=win.10)).
Evento WebView.NewWindowRequested | El nuevo evento [WebView.NewWindowRequested](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.newwindowrequested) te permite responder cuando un script de un control WebView solicita una nueva ventana del explorador. Para el control WebView HTML, consulta el evento [MSWebViewNewWindowRequested](https://docs.microsoft.com/microsoft-edge/webview).
Evento WebView.PermissionRequested | El nuevo evento [WebView.PermissionRequested](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.permissionrequested) permite al contenido de WebView aprovechar las nuevas API de HTML5 enriquecidas que requieren permiso especial del usuario, como la geolocalización. Para el control WebView HTML, consulta el evento [MSWebViewPermissionRequested](https://docs.microsoft.com/previous-versions/windows/apps/dn806030(v=win.10)).
Evento WebView.UnviewableContentIdentified | El nuevo evento [WebView.UnviewableContentIdentified](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.unviewablecontentidentified) te permite responder cuando se navega el WebView a contenido que no es de web, como un archivo PDF o documento de Office. Para los controles WebView HTML, consulta el evento [MSWebViewUnviewableContentIdentified](https://docs.microsoft.com/microsoft-edge/webview).
Método WebView.AddWebAllowedObject | Puedes llamar al nuevo método [WebView.AddWebAllowedObject](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.addweballowedobject) para insertar un objeto de WinRT en un WebView XAML y luego llamar a sus funciones del JavaScript de confianza hospedado en ese WebView. Por ejemplo, el contenido web puede mostrar notificaciones del sistema al solicitar que su aplicación principal llame a la API de WinRT de [ToastNotificationManager](https://docs.microsoft.com/uwp/api/windows.ui.notifications.toastnotificationmanager). Para el control WebView HTML, consulta el método [addWebAllowedObject](https://docs.microsoft.com/microsoft-edge/webview).
Método WebView.ClearTemporaryWebDataAsync | Cuando un usuario interactúa con el contenido web dentro de un control WebView XAML, el control WebView almacena en caché datos en función de la sesión de ese usuario. Puedes llamar al nuevo método [ClearTemporaryWebDataAsync](https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.webview.cleartemporarywebdataasync) para borrar esta caché. Por ejemplo, puedes borrar la memoria caché cuando un usuario cierre sesión en la aplicación para que otro usuario no pueda obtener acceso a los datos desde la sesión anterior.
