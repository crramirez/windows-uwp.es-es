#Asignación del concepto de aplicaciones de Windows para desarrolladores de Android e iOS

Si eres un desarrollador con habilidades o código de Android o iOS y quieres hacer el cambio a Windows 10 y la Plataforma universal de Windows (UWP), este recurso tiene todo lo que necesitas para asignar características de la plataforma, y tus conocimientos, entre las tres plataformas.

Consulta también el contenido de migración en [Migrar de iOS a la UWP](ios-to-uwp-root.md).

## Interfaz de usuario (UI)

|  **Concepto general** | **Android** | **iOS** | **UWP de Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Lenguaje de diseño.** Un conjunto de convenciones que indica el aspecto y comportamiento de las aplicaciones en la plataforma. | En las directrices **Diseño de material de Android** se proporciona un lenguaje visual que deben seguir los diseñadores y desarrolladores de Android. | En **Directrices de interfaz humana** se ofrece asesoramiento para los desarrolladores y diseñadores de iOS. | [
							En **Diseño de aplicaciones de Windows para UWP**](https://dev.windows.com/design) se muestra cómo crear una aplicación para que tenga un aspecto fantástico en todos los dispositivos Windows 10. Encontrarás aspectos básicos sobre el diseño de la interfaz de usuario (UI), técnicas de diseño dinámico y una lista completa de directrices detalladas.<br/> |
|  **Lenguaje de marcado de la interfaz de usuario.** Un lenguaje de marcado que representa y describe una interfaz de usuario y sus componentes. En cada plataforma se proporciona un editor para la edición tanto visual y como de marcado.<br/> | **Diseños XML** que se editan mediante **Studio Android** o **Eclipse**. | **XIB** y **guiones gráficos** que se editan mediante el **configurador de interfaz de usuario** en Xcode. | **[XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt185595.aspx)**que se edita mediante **[Microsoft Visual Studio](https://www.visualstudio.com/)** y **[Blend para Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)**.<br/><br/>[Plataforma XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt228259.aspx)<br/><br/>[Crear una interfaz de usuario con XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt228349.aspx)<br/><br/>[Definir diseños con XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt228350.aspx) |
|  **Controles de interfaz de usuario integrados.** Elementos de interfaz de usuario que proporciona la plataforma, como botones, controles de lista y controles de texto. | Clases **view** y **view group** predefinidas conocidas como widgets, diseños, campos de texto, contenedores, controles de fecha y hora, y los controles expertos. | **Vistas** y **controles** que se encuentran en la biblioteca de objetos de Xcode y que se enumeran en el catálogo de interfaz de usuario UIKit. Entre las vistas se incluyen vistas de imagen, vistas de selector y vistas de desplazamiento. Entre los controles se incluyen botones, selectores de fecha y campos de texto. | En la plataforma XAML se proporciona un conjunto amplio de **controles integrados**, como botones, controles de lista, paneles, controles de texto, barras de comandos, selectores, contenido multimedia y la entrada manuscrita.<br/><br/>[Agregar controles y controlar eventos](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **Control de eventos de control.** Define la lógica que se ejecuta cuando se desencadenan eventos en los controles de interfaz de usuario. | Los **controladores de eventos** y **escuchas de eventos** se agregan en XML o mediante programación. | Los controles envían mensajes de **acción** a los **destinos**. | Puedes definir métodos para controlar los eventos de un control XAML en un **archivo de código subyacente** adjunto a la página XAML. Los **controladores de eventos** siempre se escriben en código. Sin embargo, puedes enlazar esos controladores a los eventos en el marcado XAML o en el código.<br/><br/>[Agregar controles y controlar eventos](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx)<br/><br/>[Introducción a eventos y eventos enrutados](https://msdn.microsoft.com/library/windows/apps/xaml/mt185584.aspx) |
|  **Enlace de datos.** Patrón de diseño de software que permite a la interfaz de usuario de la aplicación representar datos y, opcionalmente, mantenerse sincronizada con dichos datos.  | Se proporciona una **biblioteca de enlaces de datos**, aunque se encuentra en la versión beta. | No existe ningún sistema de enlaces integrados en iOS. La **observación clave-valor** se puede ampliar para realizar el enlace de datos, ya sea mediante una biblioteca de terceros o escribiendo código adicional. Los controles usan un método de delegado o devolución de llamada para obtener los datos. | La plataforma UWP controla el **enlace de datos** para ti. La extensión de marcado **[{x:Bind}](https://msdn.microsoft.com/library/windows/apps/mt204783.aspx)** se usa para sacar provecho del enlace de alto rendimiento. **[{Binding}](https://msdn.microsoft.com/library/windows/apps/mt204782.aspx)** se usa para sacar provecho de más características. Luego, solo tienes que configurar el enlace para elegir si la plataforma usará **enlaces unidireccionales** para mostrar los valores de un origen de datos en la interfaz de usuario o si también observará esos valores y actualizará la interfaz de usuario cuando cambien con **enlaces bidireccionales**.<br/><br/>[Enlace de datos](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) |
|  **Automatización de la interfaz de usuario.** Acceso mediante programación a los elementos de la interfaz de usuario, lo que permite que las aplicaciones estén accesibles para los productos de tecnología de asistencia y permite el uso de scripts de prueba automatizados para su interacción con la interfaz de usuario. | Los valores **Text labels**, **contentDescription** y **hint** ayudan a garantizar que los elementos de la interfaz de usuario se pueden encontrar mediante la automatización. Android Studio permite escribir pruebas de interfaz de usuario con los marcos de prueba **UI Automator** y **Espresso**. | El **instrumento de automatización** permite escribir scripts de prueba de interfaz de usuario automatizados que identifican elementos mediante opciones de configuración de **accesibilidad** o la posición del elemento en la **jerarquía de elementos**. | Con la configuración inicial, puedes acceder mediante programación a los elementos de interfaz de usuario integrados en UWP mediante la **[automatización de la interfaz de usuario](https://msdn.microsoft.com/library/windows/apps/ee684076.aspx)**.<br/>**
							La [personalización de sistemas de automatización del mismo nivel](https://msdn.microsoft.com/library/windows/apps/mt297667.aspx)** te permite proporcionar compatibilidad para la automatización para tus propias clases de interfaz de usuario personalizadas. El **[proyecto de pruebas de interfaz de usuario codificada](https://msdn.microsoft.com/library/dd286726.aspx#VerifyingCodeUsingCUITCreate)** en Visual Studio permite probar automáticamente toda tu aplicación a través de la interfaz de usuario o probar la interfaz de usuario de manera aislada. |
|  **Cambiar el aspecto de un control.** Edita el tamaño, color y otros atributos. | Los controles tienen **propiedades** que se pueden editar mediante la herramienta del diseñador, en el marcado XML o mediante programación. | Los controles tienen **atributos** que se pueden editar con **Attributes Inspector** en el generador de interfaz de usuario o mediante programación. | Puedes editar las **propiedades** de los controles en el marcado XAML o mediante programación, con Visual Studio y Blend para Visual Studio.<br/><br/>[Agregar controles y controlar eventos](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **Estilos visuales reutilizables.** Aplica cambios visuales en un número de controles en un formato reutilizable. | Los **estilos XML** son conjuntos de propiedades que se aplican a uno o varios controles. | En la configuración inicial, iOS no admite estilos visuales reutilizables, pero el protocolo UIAppearance permite que varios controles compartan atributos comunes. | Puedes crear **[estilos](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.style.aspx)** reutilizables, que se puede aplicar a varios controles y almacenar en un **[ResourceDictionary](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.resourcedictionary.aspx)** para facilitar su reutilización.<br/><br/>[Inicio rápido: aplicar estilos a los controles](https://msdn.microsoft.com/library/windows/apps/xaml/hh465381.aspx) |
|  **Editar la estructura visual de los controles.** Personaliza la estructura visual de un control más allá de la simple modificación de propiedades o atributos; por ejemplo, al mover el texto de una casilla por debajo de esta. | En Android no existe ningún método simple para editar la estructura visual de los controles. | En iOS no existe ningún método simple para editar la estructura visual de los controles. | Para personalizar la estructura visual de un control, puedes copiar y editar su **[plantilla de control](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.controltemplate.aspx)** en el marcado XAML.<br/><br/>[Inicio rápido: Plantillas de control](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374.aspx)  |
|  **Gestos táctiles integrados.** Proporciona compatibilidad con la entrada táctil personalizada mediante el control de eventos de gestos resumidos de alto nivel, como pulsación y doble pulsación en las vistas y los controles. | Los **detectores de gestos** detectan gestos táctiles comunes, como por ejemplo, desplazamiento, presión prolongada, pulsación, doble pulsación y deslizamiento. | El marco UIKit proporciona **reconocedores de gestos** integrados que detectan gestos táctiles, como por ejemplo, pulsación, reducción, panorámica, deslizamiento, rotación y presión prolongada. | Los **elementos de interfaz de usuario** permiten controlar los **eventos de gestos estáticos**, como por ejemplo, pulsación, doble pulsación, pulsación derecha y mantenimiento de la pulsación, así como **eventos de gestos de manipulación**, como por ejemplo, deslizamiento, deslizamiento rápido, giro, reducción y estiramiento. Los eventos de gestos son **eventos enrutados** y se pueden controlar mediante objetos primarios que contiene el elemento secundario UIElement.<br/><br/>[Interacciones táctiles](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)<br/><br/>[Interacciones del usuario personalizadas: gestos, manipulaciones e interacciones](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx#gestures__manipulations__and_interactions) |

## Navegación y estructura de aplicaciones

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Diseños.** El diseño define la estructura de la interfaz de usuario. | El diseño está compuesto por **grupos de vistas**, tales como **LinearLayout** y **RelativeLayout**, que pueden anidar otras vistas o grupos de vistas. | El diseño está compuesto por un objeto **UIViewController** que contiene objetos **UIView**, que se pueden anidar.  | El código XAML que proporciona un sistema de diseño flexible compuesto por **clases de panel de diseño**, como **[Canvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.canvas.aspx)**, **[Grid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.grid.aspx)**, **[RelativePanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.relativepanel.aspx)** y **[StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx)** para diseños estáticos y dinámicos. **
							Las [propiedades](https://msdn.microsoft.com/library/ms171352.aspx)** se usan para controlar el tamaño y la posición de los elementos.<br/><br/>[Definir diseños con XAML](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx)<br/> |
|  **Navegación punto a punto.** Presenta al usuario métodos de navegación entre páginas de la misma importancia jerárquica. | Las **pestañas**, las **vistas de deslizamiento** y los **cajones de navegación** proporcionan una **navegación lateral**. | Los **controladores de la barra de pestañas**, **controladores de vista en dos paneles** y **controladores de vista de página** permite una navegación entre vistas de jerarquía igual. | Puedes mostrar una lista persistente de vínculos o pestañas situadas encima de contenido mediante **[pestañas o tablas dinámicas](https://msdn.microsoft.com/library/windows/apps/dn997788.aspx)**. El **[panel de navegación o vista en dos paneles](https://msdn.microsoft.com/library/windows/apps/dn997787.aspx)** permite mostrar una lista de vínculos junto con el contenido.<br/><br/>[Navegación](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx)<br/><br/>[Navegación de punto a punto entre dos páginas](https://msdn.microsoft.com/library/windows/apps/mt465735.aspx) |
|  **Navegación jerárquica.** Navega entre las páginas principales y secundarias de una jerarquía. | Las **listas**, **listas de cuadrículas**, **botones** y otros controles proporcionan una **navegación descendente** cuando se usan con **intenciones** para cargar otras **actividades**. | Los **controladores de navegación** permiten a los usuarios navegar entre los niveles de una jerarquía. | **
							Los [controles de navegación centralizada](https://msdn.microsoft.com/library/windows/apps/dn449149.aspx)** permiten mostrar al usuario una vista previa del contenido que se puede seleccionar para navegar a páginas secundarias. **
							El [maestro y los detalles](https://msdn.microsoft.com/library/windows/apps/dn997765.aspx)** permiten a los usuarios elegir de una lista de resúmenes de elemento que se muestran junto a la sección de detalles correspondiente.<br/><br/>[Navegación](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx) |
|  **Navegación con el botón Atrás.** Navega hacia atrás por una aplicación. | La **Atrás** y **de** botones dentro de la barra de acciones proporcionan **ancestral** y **temporal** de navegación usando la **pila de retroceso**. | Al **controlador de navegación** se le puede agregar un botón Atrás.<br/> | Puedes controlar fácilmente las presiones del botón Atrás de software o hardware mediante la **[propiedad BackStack](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.frame.backstack.aspx)**, que permite a los usuarios recorrer el **historial de navegación**.<br/><br/>[Navegación con el botón Atrás](https://msdn.microsoft.com/library/windows/apps/mt465734.aspx) |
|  **Pantalla de presentación.** Muestra una imagen al iniciar la aplicación (se usa principalmente para la personalización de marca). | Las pantallas de presentación no se proporcionan de manera predeterminada y se implementan al editar el **fondo del tema** de las actividades iniciales. | Las aplicaciones deben tener una **imagen de inicio estática** o un **archivo de inicio XIB o de guion gráfico**. | Puedes crear una pantalla de presentación con una **imagen** y un fondo de color. [El tiempo de la pantalla de presentación se puede ampliar](https://msdn.microsoft.com/library/windows/apps/mt187309.aspx).<br/><br/>[Agregar una pantalla de presentación](https://msdn.microsoft.com/library/windows/apps/mt187306.aspx)<br/><br/>[Directrices para pantallas de presentación](https://msdn.microsoft.com/library/windows/apps/hh465338.aspx) |

## Entradas personalizadas

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Voz.** Reconocimiento de voz para la entrada de voz y funcionalidades adicionales de voz. | La entrada de voz puede la puede proporcionar cualquier aplicación que implemente un objeto **RecognizerIntent**, tal como **Búsqueda por voz de Google**. La clase **SpeechRecognizer** permite a las aplicaciones usar la API de reconocimiento de voz de Google. | No existen API integradas de reconocimiento o entrada de voz. | Puedes usar la API de **[reconocimiento de voz](https://msdn.microsoft.com/library/windows/apps/mt185615.aspx)** para interactuar con la aplicación en primer plano. Puedes usar las **[interacciones de Cortana](https://msdn.microsoft.com/library/windows/apps/mt185598.aspx)** basadas en voz para iniciar aplicaciones en primer o segundo plano y para interactuar con aplicaciones en segundo plano.<br/><br/>[Interacciones de voz](https://msdn.microsoft.com/library/windows/apps/mt185614.aspx) |
|  **Entradas de usuario personalizadas.** Controla las entradas de teclado, mouse y lápiz, entre otras. | La compatibilidad con interacciones incluye **función táctil**, **panel táctil**, **lápiz**, **mouse** y **teclado**. Los movimientos y las entradas se notifican de la misma manera que la función táctil, pero es posible detectar más información sobre el **dispositivo de entrada**. | Se proporciona compatibilidad con **función táctil**, **Apple Pencil** y **teclados** de hardware. | Encontrarás compatibilidad con una amplia variedad de interacciones, como por ejemplo, **[función táctil](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)**, **[panel táctil](https://msdn.microsoft.com/library/windows/apps/mt187313.aspx)**, **[lápiz](https://msdn.microsoft.com/library/windows/apps/mt187311.aspx)** con entrada digital, **[mouse](https://msdn.microsoft.com/library/windows/apps/mt187308.aspx)** y **[teclado](https://msdn.microsoft.com/library/windows/apps/mt185607.aspx)**. Las aplicaciones pueden controlar los datos sin tener que saber qué dispositivo de entrada se usó y, si fuera necesario, se pueden acceder a los datos de dispositivos de entrada sin procesar.<br/><br/>[Controlar la entrada de puntero](https://msdn.microsoft.com/library/windows/apps/mt404610.aspx)<br/><br/>[Interacciones del usuario personalizadas](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx) |

## Datos

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Datos de aplicaciones locales.** Almacena localmente la configuración y los archivos relacionados con la aplicación. | Los archivos locales se pueden guardar mediante **openFileOutput** y **openFileInput**. La configuración en un **archivo de preferencias compartidas** es accesible mediante **getSharedPreferences**. | Los archivos locales se pueden almacenar en el directorio de **compatibilidad con aplicaciones**, al que se accede a través de la clase **NSFileManager**. La configuración en los archivos de **preferencias** es accesible mediante la clase **NSUserDefaults**. | Las clases **[Windows.Storage](https://msdn.microsoft.com/library/windows/apps/xaml/br230562.aspx)** controlan el almacenamiento de datos local de manera unificada. La configuración se almacena como un objeto **[ApplicationDataContainer](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdatacontainer.aspx)**, al que se accede mediante la propiedad **[ApplicationData.LocalSettings](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localsettings.aspx)**. Los archivos se almacenan en un objeto **[StorageFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.storagefolder.aspx)**, al que se accede mediante la propiedad **[ApplicationData.LocalFolder](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localfolder.aspx)**.<br/><br/>[Almacenar y recuperar la configuración y otros datos de aplicación](https://msdn.microsoft.com/library/windows/apps/xaml/mt299098.aspx) |
|  **Almacenamiento de la base de datos local.** Almacena los datos de la aplicación en una base de datos relacional, con asignadores relacionales de objetos (ORM), si corresponde. | Se proporciona la base de datos **SQLite**. No hay ORM integrados. Las consultas SQL se ejecutan mediante la clase **SQLiteDatabase**. | Se proporciona la base de datos **SQLite**. El objeto **CoreData** es el marco de gráficos de objetos integrado que se puede usar con SQLite y ofrece una funcionalidad comparable con un ORM. | Puedes almacenar datos mediante **SQLite**. **[Entity Framework](https://msdn.microsoft.com/library/windows/apps/xaml/mt592863.aspx)** es un ORM integrado que elimina la necesidad de escribir grandes cantidades de código de acceso a datos y permite consultar fácilmente la base de datos sin necesidad de escribir código SQL. Puedes ejecutar consultas SQL directamente con la [biblioteca SQLite](https://msdn.microsoft.com/library/windows/apps/xaml/mt592864.aspx).<br/><br/>[Acceso a datos](https://msdn.microsoft.com/library/windows/apps/xaml/mt592862.aspx) |
|  **Bibliotecas HTTP para acceso a REST.** Bibliotecas integradas que te permiten comunicarte con servicios web y servidores web mediante HTTP(S).<br/> | Bibliotecas HTTP **HttpURLConnection** y **Volley**. | **NSURLSession**, **NSURLConnection** y **NSURLDownload**. | Puedes usar la API **[HttpClient](https://msdn.microsoft.com/library/windows/apps/xaml/windows.web.http.httpclient)** integrada para acceder a la funcionalidad HTTP común, como por ejemplo, GET, DELETE, PUT, POST, patrones comunes de autenticación, SSL, cookies e información de progreso. |
|  **Servicios de copia de seguridad en la nube.** Servicios de copia de seguridad proporcionados por la plataforma para los datos de la aplicación.  | El **administrador de copias de seguridad** de Android controla la creación de copias de seguridad de datos de aplicación en **Android Backup Service** de Google.  | Un usuario puede configurar la **copia de seguridad de iCloud** para controlar sus copias de seguridad, como por ejemplo, los datos de aplicación. Aplicaciones que usan **datos principales** compatibles con iCloud, el **almacén de pares clave-valor de iCloud** y el **almacenamiento de documentos de iCloud**. | Los datos de la aplicación que se almacenen mediante las **[API ApplicationData](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.aspx)** de sincronización (por ejemplo **[RoamingFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingfolder.aspx)** y [**RoamingSettings**](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingsettings.aspx)) se sincronizarán automáticamente en la nube y en los otros dispositivos del usuario. La sincronización se consigue mediante la cuenta de Microsoft del usuario.<br/><br/>[Directrices para perfiles móviles de datos de la aplicación](https://msdn.microsoft.com/library/windows/apps/hh465094.aspx) |
|  **Descargas de archivos HTTP.** Descarga archivos de pequeño y gran tamaño a través de HTTP. | Los objetos **URLConnection** y **HTTPURLConnection** se usan para descargar elementos a través de HTTP y FTP. También es posible usar el sistema del **administrador de descargas** para descargar elementos en segundo plano. | Los objetos **NSURLSession** y **NSURLConnection** se pueden usar para descargar archivos a través de HTTP y FTP. | Las **[API de transferencia en segundo plano](https://msdn.microsoft.com/library/windows/apps/windows.networking.backgroundtransfer.aspx)** permiten transferir archivos de manera confiable a través de HTTP(S) y FTP, teniendo en cuenta la suspensión de la aplicación, la pérdida de conectividad y los ajustes según la conectividad y duración de la batería. También puedes usar el objeto **[HttpClient](https://msdn.microsoft.com/library/windows/apps/windows.web.http.httpclient.aspx)**, que es ideal para archivos más pequeños.<br/><br/>[¿Qué tecnología de red?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Transferencias en segundo plano](https://msdn.microsoft.com/library/windows/apps/mt280377.aspx) |
|  **Sockets.** Crea sockets de datagramas UDP y TCP de bajo nivel para comunicarte con otros dispositivos a través de tu propio protocolo. | La clase **Socket** proporciona sockets TCP y la clase **DatagramSocket** proporciona un socket UDP. | Los objetos **NSStream** y **CFStream** proporcionan sockets TCP, y el objeto **CFSocket** proporciona sockets UDP. | Puedes usar la clase **[DatagramSocket](https://msdn.microsoft.com/library/windows/apps/br241319)** para comunicarte con un socket de datagramas UDP y la clase **[StreamSocket](https://msdn.microsoft.com/library/windows/apps/br226882)** para comunicarte a través de TCP o RFCOMM de Bluetooth.<br/><br/>[Conceptos básicos de redes](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[¿Qué tecnología de red?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Información general sobre los sockets](https://msdn.microsoft.com/library/windows/apps/mt280234.aspx) |
|  **WebSockets.** Proporciona una comunicación bidireccional entre un cliente y servidor, lo que permite una transferencia de datos en tiempo real. | En Android no existen bibliotecas WebSockets integradas. | En iOS no existen bibliotecas WebSockets integradas. | Las conexiones seguras a servidores compatibles con WebSockets se pueden establecer con la clase **[MessageWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.messagewebsocket.aspx)** para mensajes más pequeños con notificaciones de confirmación y con la clase **[StreamWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.streamwebsocket.aspx)** para transferencias de archivos binarios de mayor tamaño que se pueden leer en secciones.<br/><br/>[Conceptos básicos de redes](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[¿Qué tecnología de red?](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[Introducción a WebSockets](https://msdn.microsoft.com/library/windows/apps/mt186447.aspx) |
|  **Bibliotecas OAuth.** Bibliotecas OAuth que permiten acceder a proveedores OAuth de terceros y la administración de cuentas integrada en la plataforma. | No se proporciona ninguna biblioteca OAuth genérica. La clase **GoogleAuthUtil** se proporciona para la autenticación OAuth con Google Play Services.<br/> | No se proporciona ninguna biblioteca OAuth genérica. El **marco de cuentas** proporciona acceso a las cuentas de usuario que ya están almacenadas en el dispositivo, como Facebook y Twitter. | La biblioteca OAuth genérica **[Agente de autenticación web](https://msdn.microsoft.com/library/windows/apps/mt270196.aspx)** permite conectarte a servicios de proveedor de identidades de terceros. La **[caja de seguridad de credenciales](https://msdn.microsoft.com/library/windows/apps/mt270189.aspx)** permite a los usuarios guardar su información de inicio de sesión y usarla en varios dispositivos. El espacio de nombres **[Microsoft.Live](https://msdn.microsoft.com/library/windows/apps/dn896755.aspx)** permite acceder fácilmente a OAuth del SDK de Live para acceder a los servicios Microsoft.<br/><br/>[Autenticación e identidad de usuario](https://msdn.microsoft.com/library/windows/apps/mt270184.aspx)<br/><br/>[Documentación de la API Windows.Security.Authentication.Web](https://msdn.microsoft.com/library/windows/apps/windows.security.authentication.web.aspx)<br/><br/>[Ejemplo de código de WebAuthenticationBroker](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/WebAuthenticationBroker) |

## Herramientas

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **IDE.** Conjunto de herramientas que se usa para crear la aplicación. | **Android Studio** y **Eclipse**, con Google que anima a los desarrolladores hacia el uso de Android Studio. | **Xcode** | **[Visual Studio](https://www.visualstudio.com/features/universal-windows-platform-vs.aspx)** y **[Blend para Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)** cuentan con todas las herramientas que necesitas para codificar, diseñar, conectar, depurar, analizar, optimizar y probar aplicaciones para UWP. Visual Studio también te proporciona **[emuladores](https://msdn.microsoft.com/library/windows/apps/mt188754.aspx)** para dispositivos Windows 10 para que puedas probar la aplicación en una amplia variedad de dispositivos emulados.<br/><br/>[Descargas y herramientas para UWP](https://dev.windows.com/downloads) |
|  **Organización de código.** Estructura de carpetas básica de una aplicación, que a menudo se crea a partir de una plantilla inicial. | Archivo **AndroidManifest**, carpeta **java** que contiene los archivos de origen, carpeta **res** con recursos (por ejemplo, diseños y valores), scripts de compilación **Gradle** en Android Studio y scripts de compilación **Ant** en Eclipse. | Archivos de origen y **archivos de compatibilidad**, archivo **Info.plist**, **Main.storyboard** y **LaunchScreen.storyboard**. Las imágenes se almacenan en **bibliotecas de recursos**. | La aplicación para UWP contiene código XAML y archivos de código denominados Example.xaml y Example.xaml.cs, distintas imágenes en la **carpeta Recursos**, una página de inicio (por ejemplo, **MainPage.xaml** y **MainPage.xaml.cs**) y un manifiesto.<br/><br/>[Crear una aplicación "Hello, world"](https://msdn.microsoft.com/library/windows/apps/dn765018.aspx) |

## Ciclo de vida de la aplicación

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Ciclo de vida de la aplicación.** Controla eventos cuando la aplicación se inicia, suspende, reanuda y cierra, proporcionando una oportunidad para guardar y restaurar el estado de la aplicación y ejecutar otras tareas. | Cada actividad tiene su propio **ciclo de vida de la actividad** con estados como, por ejemplo, **reanudada**. **Las devoluciones de llamada del ciclo de vida**, como **onResume**, se implementan en las **clases de la actividad**. | El **ciclo de vida de aplicación** tiene estados como, por ejemplo, **suspendida**. Los métodos, como **applicationDidEnterBackground:**, se implementan en el **objeto de aplicación de delegado** para ejecutar código cuando se producen cambios de estado. | La aplicación tiene los **estados de ejecución de la aplicación** NotRunning, Activated, Running, Suspending, Suspended y Resuming.<br/><br/>Puedes implementar los métodos de la **[clase Application](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.aspx)** OnLaunched, OnActivated, Suspending o Resuming en tu aplicación para ejecutar código cuando cambie el estado.<br/><br/>[Ciclo de vida de la aplicación](https://msdn.microsoft.com/library/windows/apps/mt243287.aspx) |
|  **Tareas en segundo plano.** Tareas que realizan operaciones en segundo plano y siguen ejecutándose cuando la aplicación ya no está en primer plano. | Las aplicaciones pueden iniciar **servicios** que realizan operaciones en segundo plano cuando la aplicación ya no está en primer plano. Los servicios tienen su propio **ciclo de vida** y se registran en el manifiesto. | La **ejecución en segundo plano** solo se permite para tipos de tarea específicos.<br/><br/>Las aplicaciones declaran **tareas en segundo plano admitidas** en el archivo Info.plist mediante el objeto **UIBackgroundModes**.<br/><br/>El sistema controla cuándo se ejecutan tareas en segundo plano y durante cuánto tiempo. | Puedes crear una tarea en segundo plano mediante la implementación de la interfaz **[IBackgroundTask](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.ibackgroundtask.aspx)** y el registro de la tarea en el manifiesto de la aplicación. Puede establecer una tarea para que se desencadene con un [**temporizador**](https://msdn.microsoft.com/library/windows/apps/mt186458.aspx), [**desencadenador del sistema**](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.systemtriggertype.aspx) y [**desencadenador de mantenimiento**](https://msdn.microsoft.com/library/windows/apps/mt185632.aspx).<br/><br/>[Dar soporte a tu aplicación mediante tareas en segundo plano](https://msdn.microsoft.com/library/windows/apps/mt299103.aspx)<br/><br/>[Crear y registrar una tarea en segundo plano](https://msdn.microsoft.com/library/windows/apps/mt299100.aspx)<br/><br/>[Directrices para tareas en segundo plano](https://msdn.microsoft.com/library/windows/apps/mt187310.aspx) |

## Rendimiento

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Procedimientos recomendados de rendimiento.** Directrices para crear aplicaciones que sean rápidas y dinámicas, y que tengan en cuenta la duración de la batería con un tiempo de inicio rápido. | Android ofrece la guía de aprendizaje **Best Practices for Performance**. | iOS proporciona el documento **Performance Overview**. | Puedes leer la **[Guía de rendimiento](https://msdn.microsoft.com/library/windows/apps/mt270266.aspx)** detallada, con secciones que cubren temas como por ejemplo, establecer objetivos de rendimiento, medir el rendimiento, administrar la memoria, animaciones suaves, acceso eficaz al sistema de archivos y herramientas disponibles para la generación de perfiles y rendimiento. |
|  **Optimizar la vista de una interfaz de usuario dinámica.** Mejorar el rendimiento mediante la optimización de vistas. | Optimizar las **jerarquías de diseño** mediante la herramienta Visor de jerarquías, **reutilizar diseños** y cargar **vistas a petición** son técnicas que ayudan a que la interfaz de usuario responda a los subprocesos y evite cuadros de diálogo tipo "La aplicación no responde" (**ANR**).<br/> | Corregir los problemas en la interfaz de usuario relacionados con la **representación fuera de la pantalla**, las **capas mezcladas** y la **rasterización** con la herramienta **Core Animation** para ayudar a que la interfaz de usuario permanezca dinámica. | Puedes **optimizar** fácilmente el **marcado** y los **diseños** XAML siguiendo unos sencillos pasos. Entre las técnicas se incluyen la reducción de la estructura de diseño, la minimización del número de elementos y la minimización del exceso de dibujo. <br/><br/>[Mantener la capacidad de respuesta del subproceso de la interfaz de usuario](https://msdn.microsoft.com/library/windows/apps/mt185403.aspx)<br/><br/>[Optimizar el marcado XAML](https://msdn.microsoft.com/library/windows/apps/mt204779.aspx)<br/><br/>[Optimiza tu diseño XAML](https://msdn.microsoft.com/library/windows/apps/mt404609.aspx) |
|  **Subprocesos.** Usa los subprocesos para mantener una **interfaz de usuario dinámica** y ejecutar varias **tareas en paralelo**. | Los subprocesos se logran mediante las clases **Runnable**, **Handler**, **ThreadPoolExecutor**, y el nivel superior **AsyncTask**. | Los subprocesos se logran mediante los objetos **NSThread**, **Grand Central Dispatch** y **NSOperation** de mayor nivel. | Puedes trabajar con subprocesos al enviar **elementos de trabajo** al **conjunto de subprocesos** con **[RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.threading.threadpool.runasync.aspx)**. Puedes usar un temporizador para enviar un elemento de trabajo con **[CreateTimer](https://msdn.microsoft.com/library/windows/apps/br230590.aspx)** y crea un elemento de trabajo repetitivo con **[CreatePeriodicTimer](https://msdn.microsoft.com/library/windows/apps/br230589.aspx)**.<br/><br/>[Enviar un elemento de trabajo al grupo de subprocesos](https://msdn.microsoft.com/library/windows/apps/mt187339.aspx)<br/><br/>[Enviar un elemento de trabajo con un temporizador](https://msdn.microsoft.com/library/windows/apps/mt187341.aspx)<br/><br/>[Crear un elemento de trabajo periódico](https://msdn.microsoft.com/library/windows/apps/mt187338.aspx)<br/><br/>[Procedimientos recomendados para usar el grupo de subprocesos](https://msdn.microsoft.com/library/windows/apps/mt187336.aspx) |
|  **Programación asincrónica.** Evita la complejidad de los subprocesos al sacar partido de modelos de programación asincrónica para mantener la capacidad de respuesta del subproceso de interfaz de usuario.  | El uso de **subprocesos es necesario** para crear clases asincrónicas propias. Algunas clases integradas son asincrónicas. | El uso de **subprocesos es necesario** para crear clases asincrónicas propias. Algunas clases integradas son asincrónicas. | Puedes usar patrones asincrónicos para evitar bloquear el subproceso principal al crear API propias, por ejemplo, con objetos **async** y **await** en C# y Visual Basic. Puedes usar las API asincrónicas integradas que terminan con la palabra **Async**.<br/><br/>[Programación asincrónica](https://msdn.microsoft.com/library/windows/apps/mt187335.aspx)<br/><br/>[Llamar a API asincrónicas en C# o Visual Basic](https://msdn.microsoft.com/library/windows/apps/mt187337.aspx) |
|  **Optimización de vistas de lista.** Patrones integrados para ayudar en la optimización de las listas de datos, que con frecuencia tienen un rendimiento deficiente cuando se necesitan mostrar grandes cantidades de datos. | El patrón de diseño **ViewHolder** se usa para evitar varias de búsquedas de vistas, lo que permite usar elementos de interfaz de usuario reutilizables. | Se puede crear una variedad de optimizaciones para mejorar el rendimiento del objeto **UITableView**, no hay elementos integrados. | Puedes usar los controles [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) y [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx), que proporcionan **virtualización de la interfaz de usuario** en la configuración inicial. Esto ofrece una experiencia de movimiento panorámico y desplazamiento suaves, así como un tiempo de inicio más rápido. También puedes implementar los objetos [IList](https://msdn.microsoft.com/library/windows/apps/system.collections.ilist.aspx) e [INotifyCollectionChanged](https://msdn.microsoft.com/library/windows/apps/system.collections.specialized.inotifycollectionchanged.aspx) en el origen de datos, lo que proporciona la **virtualización de datos** y mejora aún más el rendimiento.<br/><br/>[Optimización de interfaz de usuario de ListView y GridView](https://msdn.microsoft.com/library/windows/apps/mt204776.aspx)<br/><br/>[Virtualización de datos de ListView y GridView](https://msdn.microsoft.com/library/windows/apps/mt574120.aspx) |

## Monetización

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Compras desde la aplicación.** Características de la plataforma que permiten al usuario realizar compras desde las aplicaciones. | La **facturación desde la aplicación** la proporciona Google Services. Los productos se agregan a la **Consola para Desarrolladores de Google Play**. Las compras desde la aplicación se implementan con la **Google Play Billing Library**. | Los productos se agregan a **iTunes Connect**. Las compras desde la aplicación se implementan mediante el marco **StoreKit**.<br/><br/>Los productos se compran mediante **SKMutablePayment** y **SKPaymentQueue**. | Las compras de productos desde la aplicación de la aplicación se crean [agregándolas a tu aplicación y enviándolas a la Tienda](https://msdn.microsoft.com/library/windows/apps/mt148551.aspx). <br/><br/>Usas la **[clase CurrentApp](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.aspx)** para definir las compras desde la aplicación. <br/><br/>Usas el objeto **[CurrentApp.RequestProductPurchaseAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.requestproductpurchaseasync.aspx)** para mostrar la interfaz de usuario que permite a los clientes a comprar el producto.<br/><br/>[Habilitar compras de productos desde la aplicación](https://msdn.microsoft.com/library/windows/apps/mt219684.aspx) |
|  **Compras desde la aplicación consumibles.** Productos desde la aplicación que se pueden comprar, usar y luego volver a comprar. | Las compras consumibles se habilitan al realizar una compra normal y luego consumir con el objeto **consumePurchase**, lo que permite comprar, usar y luego volver a comprar. | Los productos consumibles se **definen como productos consumibles** en iTunes Connect. | Puedes admitir consumibles al [definir su tipo de producto como Consumible cuando los envíes](https://msdn.microsoft.com/library/windows/apps/mt148534.aspx) a la Tienda. Luego, llamas a **[CurrentApp.ReportConsumableFulfillmentAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.reportconsumablefulfillmentasync.aspx)** después de que se haya realizado una compra de consumible para permitir que el cliente acceda a él.<br/><br/>[Habilitar compras de productos consumibles desde la aplicación](https://msdn.microsoft.com/library/windows/apps/mt219683.aspx) |
|  **Probar compras desde la aplicación.** Se permite probar el código de compra desde la aplicación sin poner la aplicación en la Tienda. | Para realizar pruebas, se usa el **espacio aislado de facturación desde la aplicación**.  | Para realizar pruebas, se usan **cuentas de evaluador del espacio aislado**. | Puedes probar las compras desde la aplicación mediante la clase **[CurrentAppSimulator](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentappsimulator.aspx)** en lugar del objeto CurrentApp.<br/><br/> |
|  **Pruebas.** Se permite limitar fácilmente el contenido o quitar la publicidad según una versión de prueba de una aplicación. | Google Play ** no admite oficialmente las pruebas de aplicación**. Las pruebas o la eliminación de publicidad se logran creando una compra desde la aplicación y tomando la ruta de acceso al código correspondiente al confirmar que la compra se ha realizado correctamente. | La App Store** no admite oficialmente las pruebas de aplicación**. Las pruebas o la eliminación de publicidad se logran creando una compra desde la aplicación y tomando la ruta de acceso al código correspondiente al confirmar que la compra se ha realizado correctamente. | Puedes ofrecer una versión de prueba gratuita de tu aplicación al usar la **[opción 'Prueba gratuita'](https://msdn.microsoft.com/library/windows/apps/mt148548.aspx)** cuando envías la aplicación a la Tienda. Luego puedes usar el objeto **[LicenseInformation.IsTrial](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.istrial.aspx)** para comprobar el estado de prueba de la aplicación y presentar distintas rutas de código, según corresponda. Puedes registrar el [evento LicenseChanged](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.licensechanged) para que reciba notificación cuando el usuario cambia el estado de prueba mientras se ejecuta la aplicación.<br/><br/>[Excluye o limita características en una versión de prueba](https://msdn.microsoft.com/library/windows/apps/mt219685.aspx) |

## Adaptarse a varias plataformas

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Interfaz de usuario adaptativa: diseños flexibles.** Se admiten distintos tamaños de pantalla con un alto y ancho flexibles. | Los diseños flexibles se pueden obtener mediante los valores **wrap_content** y **match_parent** en objetos LinearLayout o usando objetos RelativeLayout para la alineación. | Los diseños flexibles se pueden obtener mediante el **modelo adaptativo** con guiones gráficos universales, lo que usa el **diseño automático** con **restricciones** y **rasgos**, como objetos horizontalSizeClass y displayScale que se aplican a los controladores de vista. | Puedes crear un diseño fluido mediante **propiedades de diseño** y **paneles** con una combinación de tamaños fijos y dinámicos.<br/><br/>[Definir diseños con XAML: Paneles y propiedades de diseño](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#layout_overview)<br/><br/>[Diseño con capacidad de respuesta 101](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **Interfaz de usuario adaptativa: diseños personalizados.** Se admiten diferentes tamaños de pantalla con diseños de destino independientes. | Se proporcionan archivos de diseño alternativos para distintas configuraciones de pantalla en el directorio de recursos mediante **calificadores de configuración**, como **pequeño**, **grande**, **ldpi** y **hdpi**, lo que permite dirigirse a diseños personalizados para pantallas de distintos tamaños y densidades. | Define un **guion gráfico de iPhone e iPad independiente** para personalizar los diseños según las distintas familias de dispositivos en una aplicación universal. | Puedes crear un diseño personalizado al definir **archivos de marcado XAML diferentes** por familia de dispositivos.<br/><br/>[Definir diseños con XAML: diseños personalizados](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#tailored_layouts) |
|  **Interfaz de usuario adaptativa: diseños dinámicos.** Responde a los cambios de tamaño de pantalla, como la rotación, o a un cambio en el tamaño de una ventana. | El uso de diseños flexibles con objetos **LinearLayout** y **RelativeLayout** o proporcionar archivos de diseño alternativos para distintas orientaciones permiten diseños dinámicos. | Cuando el **tamaño** o los **rasgos** de una vista cambian, se aplican las **restricciones** especificadas en los guiones gráficos. | Puedes redistribuir, cambiar la posición, cambiar el tamaño, mostrar o reemplazar fácilmente secciones de la interfaz de usuario en tiempo de ejecución en respuesta a los cambios del tamaño de ventana mediante los objetos **[VisualState](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.aspx)**, **[VisualStateManager](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstatemanager.aspx)** y **[AdaptiveTrigger](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.adaptivetrigger.aspx)**.<br/><br/>[Definir diseños con XAML: estados visuales y desencadenadores de estado](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#visual_states_and_state_triggers)<br/><br/>[Diseño con capacidad de respuesta 101](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **Compatibilidad con funcionalidades de dispositivos diferentes.** Saca provecho de las características de hardware avanzadas y, al mismo tiempo, admite dispositivos que no disponen de ellas. | Las pruebas de las características del dispositivo en tiempo de ejecución mediante el objeto **PackageManager.hasSystemFeature** te permite decidir si se puede ejecutar código específico del hardware. | No existe **una comprobación única** que puedes realizar en tiempo de ejecución para probar las características del dispositivo. Debes probar cada característica de forma específica para decidir si se puede ejecutar código específico del hardware. | Puedes agregar **SDK de extensión de plataforma** al paquete para dirigirte a la funcionalidad adicional que se ofrece en las distintas familias de dispositivo, por ejemplo, teléfonos, escritorio e IoT. Usa la **[API ApiInformation](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** para comprobar la presencia de tipos y miembros en tiempo de ejecución y puedes llamar a esos tipos y miembros solo si están presentes. |
|  **Compatibilidad con funcionalidades de dispositivos diferentes.** Saca provecho de las características de hardware avanzadas y, al mismo tiempo, admite dispositivos que no disponen de ellas. | La **biblioteca de compatibilidad de Android** se puede empaquetar con tu aplicación para que algunas API más recientes estén disponibles para los usuarios con versiones anteriores de Android. Las pruebas de nivel de API en tiempo de ejecución se pueden realizar mediante **Build.Version.SDK_INT**. | Las comprobaciones estándares en tiempo de ejecución se usan para averiguar si las API están disponibles, como el método **class** para comprobar si una clase existe y **respondsToSelector:** para comprobar los métodos en las clases.  | Puedes usar el objeto **[ApiInformation.IsApiContractPresent](https://msdn.microsoft.com/library/windows/apps/dn949005.aspx)** para identificar si hay un contrato de API con un número principal y secundario especificado. También puedes usar la **[API ApiInformation](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)** para comprobar la presencia de tipos y miembros en tiempo de ejecución y puedes llamar a esos tipos y miembros solo si están presentes. |

## Notificaciones

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Iconos y distintivos.** Presenta actualizaciones a los usuarios en la pantalla principal. | Los **widgets de aplicación** son vistas en la aplicación que se pueden integrar en la pantalla principal y pueden recibir actualizaciones periódicas. En Android no existe ningún **sistema de distintivos**. No existe ningún sistema idéntico a los iconos. | En iOS no existen **iconos ni widgets**. Puedes agregar un **distintivo** al icono con un número que puede cambiar en respuesta a notificaciones locales o remotas. | La aplicación tiene un **icono**, que se pueden anclar a la pantalla Inicio y se usa para mostrar la selección de texto, imágenes y un **distintivo** con glifos y números. Puedes actualizar el contenido de los iconos de la aplicación a través de notificaciones de inserción o programaciones predefinidas. Los iconos pueden ser adaptativos y pueden cambiar en función de dónde se muestran.<br/><br/>[Crear iconos](https://msdn.microsoft.com/library/windows/apps/xaml/mt185605.aspx)<br/><br/>[Crear iconos adaptables](https://msdn.microsoft.com/library/windows/apps/xaml/mt590880.aspx)<br/><br/>[Elegir un método de entrega de notificaciones](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[Directrices sobre iconos y distintivos](https://msdn.microsoft.com/library/windows/apps/xaml/hh465403.aspx) |
|  **Mostrar notificaciones.** Tipos de notificaciones que se pueden mostrar. | Las notificaciones se pueden mostrar en el **área de notificación** y el **cajón de notificaciones**. Las **notificaciones de visualización frontal** presentan una notificación en una pequeña ventana flotante. A las notificaciones se les pueden agregar acciones mediante la definición de un objeto **PendingIntent**. | Las notificaciones emergentes aparecen como **pancartas** o **alertas**. Puedes agregar botones de acción personalizados a las **notificaciones accionables**, que se definen con el objeto **UIMutableUserNotificationAction**. | Puedes crear notificaciones emergentes adaptativas llamadas **notificaciones del sistema**. Puedes definir notificaciones del sistema en el código XML con contenido visual, **acciones** que pueden ser botones, o entradas y audio.<br/><br/>[Notificaciones del sistema interactivas y adaptables](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[Elegir un método de entrega de notificaciones](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[Directrices sobre notificaciones del sistema](https://msdn.microsoft.com/library/windows/apps/xaml/hh465391.aspx) |
|  **Programar notificaciones locales.** Notificaciones locales que tu aplicación envía en una hora programada. | Las notificaciones y acciones se definen mediante un objeto **NotificationCompat.Builder** y se pueden programar y controlar desde la aplicación mediante los objetos **AlarmManager** y **BroadcastReceiver**. | Las notificaciones locales se crean mediante el objeto **UILocalNotification**y se pueden programar mediante el objeto ** UILocalNotification.scheduleLocalNotification:**. | Puedes programar una notificación de sistema mediante el objeto **[ScheduledToastNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtoastnotification.aspx)**. Puedes enviar una notificación de icono desde la aplicación mediante la **[clase TileNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.tilenotification.aspx)** o programar una notificación de icono mediante el objeto [ScheduledTileNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtilenotification.aspx).<br/><br/>[Notificaciones del sistema interactivas y adaptables](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[Enviar una notificación de icono local](https://msdn.microsoft.com/library/windows/apps/xaml/mt593299.aspx) |
|  **Enviar notificaciones de inserción.** Notificación que se envía desde un servidor de notificación de inserción y, opcionalmente, controlada desde la aplicación. | **Google Cloud Messaging** proporciona compatibilidad con notificaciones de inserción para Android. | Las notificaciones de inserción o remotas las proporciona **Apple Push Notification service (APN)**. | Se reciben notificaciones de inserción enviadas desde **Servicios de notificaciones de inserción de Windows (WNS)**, que pueden ser de tipo icono, notificación del sistema, distintivo o notificación sin procesar. Puedes usar el evento de entrega de notificaciones [PushNotificationReceived](https://msdn.microsoft.com/library/windows/apps/xaml/windows.networking.pushnotifications.pushnotificationchannel.pushnotificationreceived.aspx) para recibir notificaciones mientras la aplicación esté en ejecución.<br/><br/>[Introducción a los Servicios de notificaciones de inserción de Windows (WNS)](https://msdn.microsoft.com/library/windows/apps/xaml/mt187203.aspx)<br/><br/>[Introducción a las notificaciones sin procesar](https://msdn.microsoft.com/library/windows/apps/xaml/mt187200.aspx) |

## Capturar y representar contenido multimedia

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Capturar contenido multimedia.** Grabar contenido audio visual. | El uso de una **intención**, como MediaStore.ACTION_VIDEO_CAPTURE, permite la captura de contenido multimedia con una aplicación de cámara existente. El uso de la biblioteca **android.hardware.camera2** o **camera** permite la implementación de una interfaz de cámara personalizada. Para capturar audio se pueden usar API **MediaRecorder**. | El objeto **UIImagePickerController** permite la captura de vídeo y fotos con la interfaz de usuario del sistema. La clase **AVFoundation**, como **AVCaptureSession**, permite un acceso directo a la cámara. <br/>La clase **AVAudioRecorder** permite la grabación de audio. | Puedes capturar fotos y vídeo mientras se usa la interfaz de usuario de la cámara integrada con la **[clase CameraCaptureUI](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.cameracaptureui.aspx)**. Puede interactuar con la cámara en un nivel bajo y capturar audio con las clases de **[Windows.Media.Capture](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.aspx)**, como la **[API MediaCapture](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.mediacapture.aspx)**. <br/><br/>[Capturar fotografías y vídeos con CameraCaptureUI](https://msdn.microsoft.com/library/windows/apps/xaml/mt282142.aspx)<br/><br/>[Capturar fotografías y vídeos con MediaCapture](https://msdn.microsoft.com/library/windows/apps/xaml/mt243896.aspx) |
|  **Reproducción de contenido multimedia.** Reproducir archivos de audio y vídeo. | Para la reproducción de archivos de audio y vídeo se usan las clases **MediaPlayer** y **AudioManager**. | Para la reproducción de archivos de audio y vídeo se usan los objetos **AVKit framework**, **AVAudioPlayer** y **Media Player Framework**. | Puedes usar las clases **[MediaSource](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.core.mediasource.aspx)**, **[MediaElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx)** y **[MediaPlayer](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplayer.aspx)** para reproducir audio y vídeo desde orígenes, tales como archivos locales y remotos.<br/><br/>[Reproducción de contenido multimedia con MediaSource](https://msdn.microsoft.com/library/windows/apps/xaml/mt592657.aspx) |
|  **Editar contenido multimedia.** Crea nuevos archivos multimedia a partir de grabaciones existentes y aplica efectos especiales. | Para la edición de contenido se pueden usar clases de bajo nivel, como **MediaCodec**, **MediaMuxer** y **android.media.effect**. | Para la edición de contenido se pueden usar las clases del marco **AV Foundation**, **AVMutableComposition**, **AVMutableVideoComposition** y **AVMutableAudioMix**. | Puedes usar las API **[Windows.Media.Editing](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.aspx)**, como **[MediaComposition](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediacomposition.aspx)** y **[MediaClip](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediaclip.aspx)** para crear composiciones multimedia a partir de archivos de audio y vídeo. Puedes agregar superposiciones de imagen y vídeo, combinar clips de vídeo, agregar audio de fondo y aplicar efectos de audio y vídeo.<br/><br/>[Composiciones y edición multimedia](https://msdn.microsoft.com/library/windows/apps/mt204792.aspx) |

## Sensores

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Sensores.** Detecta el movimiento, la posición y las propiedades medioambientales del dispositivo. | El **marco de sensor** se usa para acceder a los sensores de hardware y software con clases como, por ejemplo, **SensorManager** y **SensorEvent**.  | El **marco Core Motion** se usa para acceder a datos de sensor procesados y sin procesar. | Puedes usar las clases en **[Windows.Devices.Sensors](https://msdn.microsoft.com/library/windows/apps/windows.devices.sensors.aspx)** para acceder a las lecturas del sensor y los eventos que se desencadena cuando se reciben nuevos datos de lectura del sensor.<br/><br/>[Sensores](https://msdn.microsoft.com/library/windows/apps/xaml/mt187358.aspx) |

## Ubicación y mapas

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Ubicación.** Busca la ubicación **actual** del dispositivo y realiza un seguimiento de los **cambios**. | Las API de servicios de ubicación de Google ofrecen acceso de alto nivel a la **última ubicación conocida** con el **proveedor de ubicación combinados** mediante los métodos **getLastLocation** y **requestLocationUpdates**. El acceso de bajo nivel se proporciona en las bibliotecas de Android con el objeto **LocationManager**. | La clase **Core Location** **CLLocationManager** se usa para supervisar la ubicación de un dispositivo, con el objeto **startUpdatingLocation** para el servicio de ubicación estándar y el objeto **startMonitoringSignificantLocationChanges** para el servicio de ubicación de **cambio importante**. | Puede hacer un seguimiento de la ubicación del dispositivo con las clases en **[Windows.Devices.Geolocation](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.aspx)**. Usa el objeto **[Geolocator.GetGeopositionAsync](https://msdn.microsoft.com/library/windows/apps/br225537.aspx)** para una lectura única. Usa el objeto **[Geolocator.PositionChanged](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geolocator.positionchanged.aspx)** para obtener la ubicación periódicamente mediante un temporizador o para recibir una notificación cuando cambie la ubicación.<br/><br/>[Obtener la ubicación del usuario](https://msdn.microsoft.com/library/windows/apps/mt219698.aspx) |
|  **Mostrar mapas.** Muestra un **mapa integrado interactivo** y agrega **puntos de interés**. | Las clases **GoogleMap**, **MapFragment** y **MapView** de la **API Google Maps para Android** permiten integrar mapas en las aplicaciones. Los puntos de interés se pueden mostrar con **marcadores** y la clase **Marker** personalizable. | Los mapas se integran en las aplicaciones de iOS mediante la clase **MKMapView** en el objeto **MapKit framework**. Se pueden agregar **anotaciones** a las aplicaciones para mostrar puntos de interés mediante clases de objeto, como por ejemplo, **MKPointAnnotation**, y clases de vista, como por ejemplo, **MKPinAnnotationView**. | Puedes integrar mapas en tus aplicaciones mediante el control XAML integrado **[MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx)**, que proporciona vistas 2D, 3D y Streetside. Puedes agregar puntos de interés con un marcador, imagen o forma mediante clases como, por ejemplo, **[MapIcon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapicon.aspx)**, **[MapPolygon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolygon.aspx)** y **[MapPolyline](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolyline.aspx)**.<br/><br/>[Mostrar mapas con vistas 2D, 3D y Streetside](https://msdn.microsoft.com/library/windows/apps/mt219695.aspx)<br/><br/>[Mostrar puntos de interés en un mapa](https://msdn.microsoft.com/library/windows/apps/mt219696.aspx) |
|  **Geovalla.** Supervisa la entrada y salida de una región geográfica determinada. | Las geovallas se supervisan mediante los **servicios de ubicación** en el SDK de Google Play Services. | Las regiones se supervisan mediante la clase **CLCircularRegion** y se registran mediante el objeto **CLLocationManager.startMonitoringForRegion:**. | Puedes crear una geovalla mediante la clase **[Geofence](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofence.aspx)** y definir los **estados supervisados**, tal como la entrada o salida de una región. Controla los eventos de geovalla en primer plano mediante la **[clase GeofenceMonitor](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofencemonitor.aspx)** y en segundo plano mediante la **[clase en segundo plano LocationTrigger](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.locationtrigger.aspx)**.<br/><br/>[Configurar una geovalla](https://msdn.microsoft.com/library/windows/apps/mt219702.aspx) |
|  **Geocodificación y geocodificación inversa.** Convierte direcciones en ubicaciones geográficas (geocodificación) y convierte ubicaciones geográficas en direcciones (geocodificación inversa).<br/> | Para la geocodificación y geocodificación inversa se usa la clase **Geocoder**. | Para la geocodificación se usa la clase **CLGeocoder**. | Puedes realizar la geocodificación mediante la **[clase MapLocationFinder](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.aspx)** en **[Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)**. Usa el objeto **[FindLocationsAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsasync.aspx)** para la geocodificación y el objeto **[FindLocationsAtAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsatasync.aspx)** para la geocodificación inversa.<br/><br/>[Realizar geocodificación y geocodificación inversa](https://msdn.microsoft.com/library/windows/apps/mt219697.aspx) |
|  **Rutas e indicaciones.** Proporciona rutas, distancias e indicaciones entre dos ubicaciones geográficas. | Google ofrece la **API de indicaciones de Google Maps** del servicio web, que se puede usar en Android, aunque no se proporciona ningún SDK. | El kit de mapas proporciona la API **MKDirections**, que se puede usar para obtener información sobre una ruta e indicaciones. | Puedes solicitar una ruta a pie o en coche mediante la clase **[MapRouteFinder](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutefinder.aspx)** en **[Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)**. Las rutas se devuelven como una instancia de **[MapRoute](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproute.aspx)**, que se puede mostrar fácilmente en un objeto MapControl. Las indicaciones se devuelven dentro del objeto **[MapRouteManeuver](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutemaneuver.aspx)**.<br/><br/>[Mostrar rutas e indicaciones en un mapa](https://msdn.microsoft.com/library/windows/apps/mt219701.aspx) |

## Comunicación de una aplicación a otra

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Invocar otra aplicación.** Inicia otra aplicación y, opcionalmente, comparte datos, como vínculos, texto, fotos, vídeos y archivos. | Se usa una **intención implícita** para iniciar otra aplicación, mediante la definición de una **acción** y datos opcionales en una **intención** y su llamada mediante el objeto **startActivityForResult**.<br/> | Se pueden usar **extensiones de aplicación** para proporcionar acceso a los datos de aplicación a otra aplicación. **Esquemas de direcciones URL** permite que una dirección URL se pase a otra aplicación. | Puedes iniciar otra aplicación que se ha registrado para un URI con el objeto **[Launcher.LaunchUriAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriasync.aspx)** o **[Launcher.LaunchUriForResultsAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriforresultsasync.aspx)** para iniciar los resultados y obtener datos de la aplicación iniciada. Puedes usar el objeto **[Launcher.LaunchFileAsync](https://msdn.microsoft.com/library/windows/apps/hh701471.aspx)** para pasar un archivo a otra aplicación y que esta lo procese.<br/><br/>Puedes usar un **contrato para contenido compartido** y compartir datos fácilmente entre aplicaciones.<br/><br/>[Iniciar la aplicación predeterminada de un URI](https://msdn.microsoft.com/library/windows/apps/mt228340.aspx)<br/><br/>[Iniciar una aplicación para obtener resultados](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[Iniciar la aplicación predeterminada de un archivo](https://msdn.microsoft.com/library/windows/apps/mt299102.aspx)<br/><br/>[Compartir datos](https://msdn.microsoft.com/library/windows/apps/xaml/mt243293.aspx) |
|  **Permitir la invocación de la aplicación.** Permite que la aplicación responda a una solicitud de otra aplicación. | Las aplicaciones registran una **actividad de control de intención** con un **filtro de intención** para responder a una intención implícita de otra aplicación. | El empaquetado de una **extensión de aplicación** permite compartir datos con otras aplicaciones. Las aplicaciones pueden registrar un **esquema de dirección URL personalizado** mediante la clave **CFBundleURLTypes** en Info.plist. | Puedes registrar la aplicación para que sea el controlador predeterminado de un **nombre de esquemas de URI** al registrar un **[protocolo](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.activation.activationkind.aspx#Protocol)** en el manifiesto de paquete y actualizando el controlador de eventos **[Application.OnActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onactivated.aspx)**, lo que devuelve resultados opcionalmente. Del mismo modo, puedes registrar tu aplicación para que sea el controlador predeterminado para determinados tipos de archivo mediante la adición de una declaración en el manifiesto del paquete y el control del evento **[Application.OnFileActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onfileactivated.aspx)**.<br/><br/>Puedes controlar solicitudes de contrato para contenido compartido al registrar la aplicación como destino de contenido compartido en el manifiesto y controlando el evento **[Application.OnShareTargetActivated](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.application.onsharetargetactivated.aspx)**.<br/><br/>[Iniciar una aplicación para obtener resultados](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[Administrar la activación de archivos](https://msdn.microsoft.com/library/windows/apps/mt269385.aspx)<br/><br/>[Recibir datos](https://msdn.microsoft.com/library/windows/apps/xaml/mt243292.aspx) |
|  **Copiar y pegar.** Copia y pega texto y otro contenido entre aplicaciones. | Se puede usar el **marco de portapapeles** para implementar las operaciones de copiar y pegar mediante las clases **ClipboardManager** y **ClipData**. | Se pueden usar los objetos **UIPasteboard**, **UIMenuController** y **UIResponderStandardEditActions** para implementar operaciones de copiar y pegar. | Muchos controles XAML predeterminados ya admiten las operaciones de copiar y pegar. Puedes implementar tú mismo operaciones de copiar y pegar mediante las clases **[DataPackage](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.datatransfer.datapackage.aspx)** y **[Clipboard](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.datatransfer.clipboard.aspx)** en **[Windows.ApplicationModel.DataTransfer](https://msdn.microsoft.com/library/windows/apps/br205967)**.<br/><br/>[Copiar y pegar](https://msdn.microsoft.com/library/windows/apps/xaml/mt243291.aspx) |
|  **Arrastrar y colocar.** Arrastra y coloca contenido entre aplicaciones. | La operación de arrastrar y colocar se puede implementar en una sola aplicación mediante el **marco de arrastrar y colocar de Android**. | En iOS no se proporciona ninguna API de alto nivel para arrastrar y colocar. | Puedes implementar la operación de arrastrar y colocar en la aplicación para habilitar funcionalidades de arrastrar y colocar de una aplicación a otra, del escritorio a la aplicación y de la aplicación al escritorio. La compatibilidad con operaciones de arrastrar y colocar se implementa en la clase UIElement mediante las propiedades **[AllowDrop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.allowdrop.aspx)** y **[CanDrag](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.candrag.aspx)**, y los eventos **[DragOver](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.dragover.aspx)** y **[Drop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.drop.aspx)**.<br/><br/>[Arrastrar y colocar](https://msdn.microsoft.com/library/windows/apps/xaml/mt227651.aspx) |

## Diseño de software

|  **Concepto general** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **Patrones de diseño de software.** Patrones recomendados o de uso extenso para la plataforma. | Para el desarrollo en Android, no se ha recomendado ni proporcionado ningún patrón formal, aunque es posible que la versión beta del marco de enlace de datos pueda permitir un uso más extendido del patrón **Model-View-ViewModel (MVVM)**. En varios artículos y marcos de terceros se recomiendan los métodos **Model-View-Presenter (MVP)** y **MVVM**. | El patrón **Model-View-Controller (MVC)** es un patrón común que se usa con iOS y se integra en la plataforma. | No estás limitado a un patrón específico cuando se compila para UWP.<br/><br/>Puedes usar el patrón integrado de [enlace de datos](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) para garantizar una separación clara entre las preocupaciones de datos y las de la interfaz de usuario, y evitar tener que incluir código en los controladores de eventos de la interfaz de usuario que luego actualizan los valores de las propiedades.<br/><br/>Puedes ampliar el enlace de datos para seguir el patrón **Model-View-ViewModel (MVVM)**, ya sea usando bibliotecas MVVM de terceros, como [MVVM Light Toolkit](https://mvvmlight.codeplex.com/), o implementando tu propia biblioteca y manteniendo la lógica fuera del código subyacente.<br/><br/>[The MVVM Pattern](https://msdn.microsoft.com/library/hh848246.aspx) (El patrón MVVM)<br/><br/>[Plantillas de proyecto Template 10 Visual Studio](https://github.com/Windows-XAML/Template10/wiki) |


<!--HONumber=Mar16_HO1-->


